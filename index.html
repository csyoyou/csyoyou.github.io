<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>留学生Computer Science编程作业代写 | 专业 高效 原创</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="cs,代写,代做,java,c,c++,python,android,程序,代码,作业,编程,留学生,c#,php,assignment,project,lab">
  <meta property="og:type" content="website">
<meta property="og:title" content="留学生Computer Science编程作业代写">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="留学生Computer Science编程作业代写">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="留学生Computer Science编程作业代写">
  
    <link rel="alternative" href="/atom.xml" title="留学生Computer Science编程作业代写" type="application/atom+xml">
  
  <meta name="summary" content="null">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">csyoyo</h5>
        <a href="mailto:undefined" title="cscoderman@gmail.com" class="mail">cscoderman@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect active">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            标签
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            归档
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-user"></i>
            关于我
          </a>
        </li>
    
  </ul>

  <footer class="footer">
    <img src="/img/qrcode.jpg" alt="">
  <p><h4>微信</h4></p>
  <p>csyoyo</p>
  <p><h4>邮箱</h4></p>
  <p>cscoderman@gmail.com</p>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">留学生Computer Science编程作业代写</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">留学生Computer Science编程作业代写</h1>
    <h5 class="subtitle">
         
        专业 高效 原创
        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <ul class="post-list">
  
    <li class="post-list-item">
        <article id="post-mainpage" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2111/01/11/mainpage/">留学生Computer Science编程作业代写</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2111-01-11T07:55:30.000Z" itemprop="datePublished" class="post-time">
  2111-01-11
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h2 id="团队介绍"><a href="#团队介绍" class="headerlink" title="团队介绍"></a><font face="微软雅黑">团队介绍</font></h2><p>  Team很小，运转高效，我们不是代写机构，而是一个高效协作的团队，团队成员有的擅长java，有的擅长python，有的擅长数据结构，有的擅长机器学习，<br>  有的擅长C/C++，有的擅长ios/android。通过自己设计的任务分发系统，我们可以在15分钟内迅速准确评估时间和难度，完成之后还有互相之间的code review。<br>  相比与代写机构的黑心，个人代写的不规范(我们也是个人代写发展而来)，我们团队经过不断的调整进步，具备了代写机构规范的流程优势，<br>  并且价格合理，具备了个人代写的一对一，并且熟练了解代写流程规范。</p>
<h2 id="服务内容"><a href="#服务内容" class="headerlink" title="服务内容"></a><font face="微软雅黑">服务内容</font></h2><p>  代写美国、加拿大、英国、澳洲或者其他国家的Computer Science编程作业，范围包括<font color="red">Assignment、Homework、Lab、Project、Final甚至App</font>。<br>    我不会给你看不懂的高逼格code，我的编程风格都是模仿你的slides和notes，为你量身打造，<font color="red">绝无超纲代码</font>。<br>    <font color="red">特别擅长各种疑难作业</font>，做过大量Game Design、Operating System、Database System, Web Design，得分几乎全A(90%)。</p>
<h2 id="擅长范围"><a href="#擅长范围" class="headerlink" title="擅长范围"></a><font face="微软雅黑">擅长范围</font></h2><p>  我们擅长范围包括但不限于：<br>    C C++ Java Python Php Android Ios<br>    Js Jsp Qt MFC J2ee Sql Matlab Ssh<br>    Assignment/Project/Lab/作业/编程/辅导<br>    Data structure/数据结构/机器学习/定制/制作<br>    Linux/Windows/Mac socket Algorithom/算法<br>    网站设计 Web开发 Operating system/操作系统<br>    Computer Science Everything/程序设计/app/</p>
<h2 id="质量保证"><a href="#质量保证" class="headerlink" title="质量保证"></a><font face="微软雅黑">质量保证</font></h2><p>  开发之前会详细问你的开发语言、系统环境、软件版本、测试方式(本地测试、服务器自动测试)、是否需要documention、deadline(精确到小时)<br>    沟通好时间后，我们不会临着deadline给你code。一般都是提前足够的时间给客户反馈一个版本的code，如果有问题需要反馈修改也有充足的时间。<br>    <font color="red">除了code会免费提供给客户一个运行说明word，即使客户不知道如何运行，根据说明word也可以运行验证code</font>。<br>    带checker/tester的必全过，带得分点的必全做，能顺手做掉的bonus也帮你做。<br>    小作业24小时内完成，大作业24-72小时，绝不浪费你的slip day。<br>    <font color="red">代码肯定是手写原创，不违反honor code，我给你的代码属于reference</font>。<br>    <font color="red">免费提供售后服务，包括代码运行，讲解答疑</font>。</p>
<h2 id="价格优势"><a href="#价格优势" class="headerlink" title="价格优势"></a><font face="微软雅黑">价格优势</font></h2><p>  价格通常在$100 USD以上，只有部分Lab可能低于这个价格。<br>    真正的<font color="red">无中介费用</font>，绝不漫天要价，欢迎你货比三家，支持PayPal/支付宝/微信支付。<br>    通常先收取一半定金，写好之后验收code之后付尾款。<br>    我给你的不止是一个答案，还有我作为工程师的经验，编程方法和技巧。</p>
<h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a><font face="微软雅黑">联系方式</font></h2><p>  邮箱 : cscoderman@gmail.com (请附带作业要求)<br>    微信 : cscoderman<br>    联系时，请简单或详细地说明你的要求+微信昵称(如大二，Algorithm and Data Structure)，便于我们快速报价与沟通。</p>

    
    </div>
    
</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page81" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/30/page81/">C++代写 Assignment 2</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-30T03:13:46.000Z" itemprop="datePublished" class="post-time">
  2016-12-30
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>用c++完成一个关于机器学习的基础知识，使用数据结构map，功能包括数据清理，填充dictionary 训练数据，情感分析<br>等等，最后输出结果<br><br><br><strong>Requirement</strong><br><br>Assignment 2<br>Due:​​ Oct 14th (Friday) before 11:59 PM<br>1. Learning Goals<br>Learn how to<br>1. use associative containers like ​std::unordered_set​ and ​std::unordered_map<br>2. use iterators to iterate through associative containers<br>3. use ​algorithms​ that are available in the C++ Standard Library<br>4. pass command line arguments to a C++ program<br>5. partition a C++ program in header files (.hpp) and source files (.cpp)<br>6. read, understand, and use code written by other people<br>2. Description<br>In this assignment you’ll be doing the following:<br>1. Read a raw text file containing movie reviews and ratings.<br>2. Remove the punctuations and stopwords (e.g. is, and, the, etc.) from the reviews and<br>write the contents to a clean review file.<br>3. Associate a value for all words found in the clean reviews based on the average rating of<br>the word.<br>4. Using the map between the words and their associated values, rate reviews from<br>another file that doesn’t have any rating already.<br>5. Write the ratings of the reviews to an output file.<br>2.1. Clean the data<br>The raw data with the reviews and the rating will be present in a file named<br>rawReviewRatings.txt​. Every review is given a rating between 0 - 4 (both inclusive). The<br>following are interpretation of the rating values:<br>● 0 = Negative<br>● 1 = Somewhat Negative<br>● 2 = Neutral<br>● 3 = Somewhat Positive<br>● 4 = Positive<br>Each line of review follows the following format:<br><rating> <review><br>Example:<br>4 The Jungle Book is awesome!<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>where 4 is the rating and the text “The Jungle Book is awesome!” is the review.<br>Now, your first task is to read the contents of this file and ​clean the data!<br>The following steps needs to be performed in the same order for cleaning the data:<br>1. Read the raw reviews from an input file. e.g. ​rawReviewRatings.txt<br>2. Replace the hyphens in every line of text with spaces.<br>e.g. If the review contains the word “awe-inspiring”, then it should be split into 2 words<br>namely “awe” and “inspiring”<br>3. Split each line of text into multiple words using the space character as the delimiter.<br>e.g. “The Jungle Book is awesome!” becomes | “The” | “Jungle” | “Book” | “is” |<br>“awesome!” |<br>4. Remove the punctuation marks from the words.<br>e.g. “awesome!” becomes “awesome” and “!” becomes “”<br>5. If there are any trailing/leading whitespaces, then remove them. Remember that the<br>space character (‘ ’), tab (‘\t’), newline (‘\n’), etc. are considered as whitespaces. For a<br>complete list of whitespace characters ​this​.<br>e.g. “zootopia ” becomes “zootopia”, “hello\t” becomes “hello”, and “world\n” becomes<br>“world”<br>6. Remove the empty words. i.e. words with length == 0.<br>7. Remove single lettered words. i.e. words with length == 1.<br>8. Remove stopwords. e.g. is, and, the, etc. The list of stopwords can be found in the file<br>stopwords.txt<br>9. Write the contents of the clean data to a file named ​cleanReviewRatings.txt​.<br>2.2. Fill the dictionary<br>Using the ​cleanReviewRatings.txt file, create a map/dictionary for every word that is found in<br>this file. The dictionary is of type<br>​<br>std::unordered_map<string, std::pair<long,="" long="">&gt;.<br>We associate a pair of values for each word namely its total_rating and its total_count. For<br>example, the word “fantastic” has occurred 3 times in the file ​cleanReviewRatings.txt with<br>associated ratings of 3, 4, and 3 (see the last 3 lines in the file). Therefore the word “fantastic”<br>gets a total_rating of 10 (i.e. 3 + 4 + 3 = 10) and a total_count of 3 since it had occurred 3 times<br>in the file. In a similar way, the other entries in this map are filled up as shown below. You may<br>want to read about a ​std::pair​ to understand more about how this map is organized.<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>word total_rating total_count<br>fantastic  10  3<br>Zootopia  3  1<br>Dory  1  1<br>Finding  1  1<br>worst  0  1<br>The  6  2<br>inspiring  2  1<br>Jungle  8  2<br>Book  8  2<br>good  1  1<br>Jack  0  1<br>awesome  4  1<br>Lion  5  2<br>King  5  2<br>awe  2  1<br>Jill  0  1<br>2.3. Rate new reviews<br>Using the map/dictionary that we created in the previous step, we are going to read new unrated<br>reviews from a file (e.g. ​rawReviews.txt​) and predict a rating for each review in this file. The<br>predicted rating for each review is written to an output file named ​ratings.txt​.<br>How do we predict the ratings for the unrated reviews?<br>1. Read the input file with the unrated raw reviews (e.g. ​rawReviews.txt​).<br>2. Clean the data and produce an output file named ​cleanReviews.txt​. The process for<br>cleaning the data is exactly the same as we did in step 2.1.<br>3. Rate each review by finding the rating for each word from the map/dictionary that we<br>created in step 2.2. The rating for a line of review is the average value of the rating of all<br>the words in the review. If some word in this unrated review is not found in the<br>map/dictionary, then that word is given a neutral rating of 2. If a review is empty (i.e. the<br>review contains no words in it), then such a review is also given a neutral rating of 2.<br>e.g. Let see how we computed the rating for the 2nd review in ​cleanReviews.txt (i.e.<br>“The Lion King fantastic”). We lookup the map/dictionary that we created before and get<br>the average rating for each word in this review. The average ratings of each word in this<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>review is shown below:<br>The: 6/2 = 3<br>Lion: 5/2 = 2.5<br>King: 5/2 = 2.5<br>fantastic: 10/3 = 3.33<br>Based on these individual values, this line gets and average review of 2.83 as shown in<br>the file ​ratings.txt​.<br>Rating for this line = (3 + 2.5 + 2.5 + 3.33) / 4 = 2.83<br>We are dividing by 4 since this review contains 4 words in total.<br>Another example: “Finding Nemo great”<br>Finding: 1<br>Nemo: 2 (because it is NOT found in the map)<br>great: 2 (because it is also NOT found in the map)<br>Rating for this line = (1 + 2 + 2) / 3 = 1.67<br>4. Write the ratings for all the reviews to an output file named ​ratings.txt​.<br>A high-level process diagram of the steps explained in 2.1 - 2.3 is shown. Hope this<br>visualization helps you to understand the idea in a better way! :)<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>That’s it! Now, after completing this step you may pat yourself on the back for doing an amazing<br>job with this assignment! :) Also, if you have not taken Artificial Intelligence or Machine Learning<br>before then you have just now completed your first exercise in Machine Learning. You just<br>created a program that may predict the ratings of movie reviews based on some learning it did<br>before based on some reviews that already had ratings associated with them. Well, even though<br>our algorithm is very simple, this is the basic idea behind Machine Learning. Newcomers,<br>welcome to the world of Artificial Intelligence! :)<br>3. Sample Output<br>If your program runs correctly without any errors, then NO OUTPUT will be written to the<br>console. If any input/output file cannot be opened, only then your program writes some error<br>messages to the console. All error handling is already taken care of in the file ​main.cpp​.<br>3.1. Small Data<br>INPUT FILES:<br>Rated Review File: ​rawReviewRatings.txt<br>Unrated Review File: ​rawReviews.txt<br>Stopwords File: ​stopwords.txt<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>OUTPUT FILES:<br>Cleaned Rated Review File: ​cleanReviewRatings.txt<br>Cleaned Unrated Review File: ​cleanReviews.txt<br>Ratings File: ​ratings.txt<br>3.2. “Big” Data<br>INPUT FILES:<br>Rated Review File: ​rawReviewRatingsBig.txt<br>Unrated Review File: ​rawReviewsBig.txt<br>Stopwords File: ​stopwords.txt<br>OUTPUT FILES:<br>Cleaned Rated Review File: ​cleanReviewRatings.txt<br>Cleaned Unrated Review File: ​cleanReviews.txt<br>Ratings File: ​ratings.txt<br>4. Important Details<br>1. The code for this assignment is split across 5 files.<br>a. main.cpp<br>b. a2.hpp<br>c. a2.cpp​ (This is the ONLY file you should modify!)<br>d. trim.hpp<br>e. trim.cpp<br>The .hpp files are the header files which contain only the declaration of the functions and<br>the .cpp files are the source files which contain the implementation of these functions. If<br>you want to understand more about why we have separate header and source files, then<br>maybe you should read ​this​.<br>2. Take some time to read the source code starting from the main() function that is present<br>inside the file main.cpp.<br>3. All the code you write for this assignment will only be inside the file ​a2.cpp. You should<br>not perform any file IO, print to stdout, or print to stderr in a2.cpp.<br>4. The files trim.hpp and trim.cpp are provided only to help you with trimming the<br>whitespaces in strings since doing so in C++ is not so easy as it’s in Java. You may read<br>these files to find out how to trim strings for this assignment.<br>5. You should use the following command to ​compile​​ your program.<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>$ g++ <em>.cpp -std=c++11<br>where </em>.cpp means all the .cpp files are to be compiled. You need not mention the<br>names of the .hpp files since they are included from within the .cpp files. The option<br>“-std=c++11” informs the compiler that our may contain C++11 features (e.g.<br>std::unordered_map was introduced only in C++11).<br>6. Your program takes the two files ​rawReviewRatings.txt and ​rawReviews.txt as ​command<br>line arguments​. ​​You should run your program as shown below:<br>$ ./a.out rawReviewRatings.txt rawReviews.txt<br>If you don’t give these 2 command line arguments to your program, then the following<br>error message will be printed. This error handling is already handled for you in main.cpp.<br>$ ./a.out<br>USAGE: ./a.out <reviewratingsfile> <reviewsfile><br>7. If your program works correctly without any errors, then nothing is printed to the console.<br>Only the three output files cleanReviewRatings.txt, cleanReviews.txt and ratings.txt will<br>be produced. You may even try compiling and running your program before adding any<br>code in a2.cpp to see if these 3 output files are produced. The contents of these output<br>files will be empty until the methods in a2.cpp are implemented.<br>8. You should NOT add any new functions/methods in a2.cpp.<br>9. You ​SHOULD NOT MODIFY​​ any of the following in a2.cpp:<br>a. Names of the functions<br>b. Names and types of the parameters to a function.<br>c. Return types of the functions.<br>10.An approximate number of lines of code is given for each function in a2.cpp. These are<br>the number of lines for each function in Gerald’s implementation of a2.cpp. We have<br>provided this information since it may help you to see how little code you may write if you<br>make use of the C++ Standard Library effectively. This would help you to stop and think<br>for a while before you may write a lot of code by yourself and maybe later realize that<br>you could have used some functionality from the standard library to do the same thing<br>with little code and more effectively!<br>11.Updates to this specification that may be posted on piazza are also part of this<br>specification.<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>5. Grading Scheme<br>Item  Grade<br>Correctness of your code  90<br>Code Style (indentation) &amp;<br>Implementation Comments in a2.cpp<br>10<br>TOTAL  100<br>6. Submission<br>Submit ​ONLY your a2.cpp​​ file at the following location:<br>/p/course/cs368-gerald/public/handin/<cslogin>/a2<br>Remember that ​no late work is accepted​​ in this course and there are no exceptions!<br>Hope you have a great time learning and coding associative containers and<br>algorithms using the C++ Standard Library! :)<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br><br><br><br></cslogin></reviewsfile></reviewratingsfile></string,></review></rating></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page80" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/30/page80/">C++代写 Assignment 2</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-30T03:13:46.000Z" itemprop="datePublished" class="post-time">
  2016-12-30
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>用c++完成一个关于机器学习的基础知识，使用数据结构map，功能包括数据清理，填充dictionary 训练数据，情感分析<br>等等，最后输出结果<br><br><br><strong>Requirement</strong><br><br>Assignment 2<br>Due:​​ Oct 14th (Friday) before 11:59 PM<br>1. Learning Goals<br>Learn how to<br>1. use associative containers like ​std::unordered_set​ and ​std::unordered_map<br>2. use iterators to iterate through associative containers<br>3. use ​algorithms​ that are available in the C++ Standard Library<br>4. pass command line arguments to a C++ program<br>5. partition a C++ program in header files (.hpp) and source files (.cpp)<br>6. read, understand, and use code written by other people<br>2. Description<br>In this assignment you’ll be doing the following:<br>1. Read a raw text file containing movie reviews and ratings.<br>2. Remove the punctuations and stopwords (e.g. is, and, the, etc.) from the reviews and<br>write the contents to a clean review file.<br>3. Associate a value for all words found in the clean reviews based on the average rating of<br>the word.<br>4. Using the map between the words and their associated values, rate reviews from<br>another file that doesn’t have any rating already.<br>5. Write the ratings of the reviews to an output file.<br>2.1. Clean the data<br>The raw data with the reviews and the rating will be present in a file named<br>rawReviewRatings.txt​. Every review is given a rating between 0 - 4 (both inclusive). The<br>following are interpretation of the rating values:<br>● 0 = Negative<br>● 1 = Somewhat Negative<br>● 2 = Neutral<br>● 3 = Somewhat Positive<br>● 4 = Positive<br>Each line of review follows the following format:<br><rating> <review><br>Example:<br>4 The Jungle Book is awesome!<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>where 4 is the rating and the text “The Jungle Book is awesome!” is the review.<br>Now, your first task is to read the contents of this file and ​clean the data!<br>The following steps needs to be performed in the same order for cleaning the data:<br>1. Read the raw reviews from an input file. e.g. ​rawReviewRatings.txt<br>2. Replace the hyphens in every line of text with spaces.<br>e.g. If the review contains the word “awe-inspiring”, then it should be split into 2 words<br>namely “awe” and “inspiring”<br>3. Split each line of text into multiple words using the space character as the delimiter.<br>e.g. “The Jungle Book is awesome!” becomes | “The” | “Jungle” | “Book” | “is” |<br>“awesome!” |<br>4. Remove the punctuation marks from the words.<br>e.g. “awesome!” becomes “awesome” and “!” becomes “”<br>5. If there are any trailing/leading whitespaces, then remove them. Remember that the<br>space character (‘ ’), tab (‘\t’), newline (‘\n’), etc. are considered as whitespaces. For a<br>complete list of whitespace characters ​this​.<br>e.g. “zootopia ” becomes “zootopia”, “hello\t” becomes “hello”, and “world\n” becomes<br>“world”<br>6. Remove the empty words. i.e. words with length == 0.<br>7. Remove single lettered words. i.e. words with length == 1.<br>8. Remove stopwords. e.g. is, and, the, etc. The list of stopwords can be found in the file<br>stopwords.txt<br>9. Write the contents of the clean data to a file named ​cleanReviewRatings.txt​.<br>2.2. Fill the dictionary<br>Using the ​cleanReviewRatings.txt file, create a map/dictionary for every word that is found in<br>this file. The dictionary is of type<br>​<br>std::unordered_map<string, std::pair<long,="" long="">&gt;.<br>We associate a pair of values for each word namely its total_rating and its total_count. For<br>example, the word “fantastic” has occurred 3 times in the file ​cleanReviewRatings.txt with<br>associated ratings of 3, 4, and 3 (see the last 3 lines in the file). Therefore the word “fantastic”<br>gets a total_rating of 10 (i.e. 3 + 4 + 3 = 10) and a total_count of 3 since it had occurred 3 times<br>in the file. In a similar way, the other entries in this map are filled up as shown below. You may<br>want to read about a ​std::pair​ to understand more about how this map is organized.<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>word total_rating total_count<br>fantastic  10  3<br>Zootopia  3  1<br>Dory  1  1<br>Finding  1  1<br>worst  0  1<br>The  6  2<br>inspiring  2  1<br>Jungle  8  2<br>Book  8  2<br>good  1  1<br>Jack  0  1<br>awesome  4  1<br>Lion  5  2<br>King  5  2<br>awe  2  1<br>Jill  0  1<br>2.3. Rate new reviews<br>Using the map/dictionary that we created in the previous step, we are going to read new unrated<br>reviews from a file (e.g. ​rawReviews.txt​) and predict a rating for each review in this file. The<br>predicted rating for each review is written to an output file named ​ratings.txt​.<br>How do we predict the ratings for the unrated reviews?<br>1. Read the input file with the unrated raw reviews (e.g. ​rawReviews.txt​).<br>2. Clean the data and produce an output file named ​cleanReviews.txt​. The process for<br>cleaning the data is exactly the same as we did in step 2.1.<br>3. Rate each review by finding the rating for each word from the map/dictionary that we<br>created in step 2.2. The rating for a line of review is the average value of the rating of all<br>the words in the review. If some word in this unrated review is not found in the<br>map/dictionary, then that word is given a neutral rating of 2. If a review is empty (i.e. the<br>review contains no words in it), then such a review is also given a neutral rating of 2.<br>e.g. Let see how we computed the rating for the 2nd review in ​cleanReviews.txt (i.e.<br>“The Lion King fantastic”). We lookup the map/dictionary that we created before and get<br>the average rating for each word in this review. The average ratings of each word in this<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>review is shown below:<br>The: 6/2 = 3<br>Lion: 5/2 = 2.5<br>King: 5/2 = 2.5<br>fantastic: 10/3 = 3.33<br>Based on these individual values, this line gets and average review of 2.83 as shown in<br>the file ​ratings.txt​.<br>Rating for this line = (3 + 2.5 + 2.5 + 3.33) / 4 = 2.83<br>We are dividing by 4 since this review contains 4 words in total.<br>Another example: “Finding Nemo great”<br>Finding: 1<br>Nemo: 2 (because it is NOT found in the map)<br>great: 2 (because it is also NOT found in the map)<br>Rating for this line = (1 + 2 + 2) / 3 = 1.67<br>4. Write the ratings for all the reviews to an output file named ​ratings.txt​.<br>A high-level process diagram of the steps explained in 2.1 - 2.3 is shown. Hope this<br>visualization helps you to understand the idea in a better way! :)<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>That’s it! Now, after completing this step you may pat yourself on the back for doing an amazing<br>job with this assignment! :) Also, if you have not taken Artificial Intelligence or Machine Learning<br>before then you have just now completed your first exercise in Machine Learning. You just<br>created a program that may predict the ratings of movie reviews based on some learning it did<br>before based on some reviews that already had ratings associated with them. Well, even though<br>our algorithm is very simple, this is the basic idea behind Machine Learning. Newcomers,<br>welcome to the world of Artificial Intelligence! :)<br>3. Sample Output<br>If your program runs correctly without any errors, then NO OUTPUT will be written to the<br>console. If any input/output file cannot be opened, only then your program writes some error<br>messages to the console. All error handling is already taken care of in the file ​main.cpp​.<br>3.1. Small Data<br>INPUT FILES:<br>Rated Review File: ​rawReviewRatings.txt<br>Unrated Review File: ​rawReviews.txt<br>Stopwords File: ​stopwords.txt<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>OUTPUT FILES:<br>Cleaned Rated Review File: ​cleanReviewRatings.txt<br>Cleaned Unrated Review File: ​cleanReviews.txt<br>Ratings File: ​ratings.txt<br>3.2. “Big” Data<br>INPUT FILES:<br>Rated Review File: ​rawReviewRatingsBig.txt<br>Unrated Review File: ​rawReviewsBig.txt<br>Stopwords File: ​stopwords.txt<br>OUTPUT FILES:<br>Cleaned Rated Review File: ​cleanReviewRatings.txt<br>Cleaned Unrated Review File: ​cleanReviews.txt<br>Ratings File: ​ratings.txt<br>4. Important Details<br>1. The code for this assignment is split across 5 files.<br>a. main.cpp<br>b. a2.hpp<br>c. a2.cpp​ (This is the ONLY file you should modify!)<br>d. trim.hpp<br>e. trim.cpp<br>The .hpp files are the header files which contain only the declaration of the functions and<br>the .cpp files are the source files which contain the implementation of these functions. If<br>you want to understand more about why we have separate header and source files, then<br>maybe you should read ​this​.<br>2. Take some time to read the source code starting from the main() function that is present<br>inside the file main.cpp.<br>3. All the code you write for this assignment will only be inside the file ​a2.cpp. You should<br>not perform any file IO, print to stdout, or print to stderr in a2.cpp.<br>4. The files trim.hpp and trim.cpp are provided only to help you with trimming the<br>whitespaces in strings since doing so in C++ is not so easy as it’s in Java. You may read<br>these files to find out how to trim strings for this assignment.<br>5. You should use the following command to ​compile​​ your program.<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>$ g++ <em>.cpp -std=c++11<br>where </em>.cpp means all the .cpp files are to be compiled. You need not mention the<br>names of the .hpp files since they are included from within the .cpp files. The option<br>“-std=c++11” informs the compiler that our may contain C++11 features (e.g.<br>std::unordered_map was introduced only in C++11).<br>6. Your program takes the two files ​rawReviewRatings.txt and ​rawReviews.txt as ​command<br>line arguments​. ​​You should run your program as shown below:<br>$ ./a.out rawReviewRatings.txt rawReviews.txt<br>If you don’t give these 2 command line arguments to your program, then the following<br>error message will be printed. This error handling is already handled for you in main.cpp.<br>$ ./a.out<br>USAGE: ./a.out <reviewratingsfile> <reviewsfile><br>7. If your program works correctly without any errors, then nothing is printed to the console.<br>Only the three output files cleanReviewRatings.txt, cleanReviews.txt and ratings.txt will<br>be produced. You may even try compiling and running your program before adding any<br>code in a2.cpp to see if these 3 output files are produced. The contents of these output<br>files will be empty until the methods in a2.cpp are implemented.<br>8. You should NOT add any new functions/methods in a2.cpp.<br>9. You ​SHOULD NOT MODIFY​​ any of the following in a2.cpp:<br>a. Names of the functions<br>b. Names and types of the parameters to a function.<br>c. Return types of the functions.<br>10.An approximate number of lines of code is given for each function in a2.cpp. These are<br>the number of lines for each function in Gerald’s implementation of a2.cpp. We have<br>provided this information since it may help you to see how little code you may write if you<br>make use of the C++ Standard Library effectively. This would help you to stop and think<br>for a while before you may write a lot of code by yourself and maybe later realize that<br>you could have used some functionality from the standard library to do the same thing<br>with little code and more effectively!<br>11.Updates to this specification that may be posted on piazza are also part of this<br>specification.<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br>5. Grading Scheme<br>Item  Grade<br>Correctness of your code  90<br>Code Style (indentation) &amp;<br>Implementation Comments in a2.cpp<br>10<br>TOTAL  100<br>6. Submission<br>Submit ​ONLY your a2.cpp​​ file at the following location:<br>/p/course/cs368-gerald/public/handin/<cslogin>/a2<br>Remember that ​no late work is accepted​​ in this course and there are no exceptions!<br>Hope you have a great time learning and coding associative containers and<br>algorithms using the C++ Standard Library! :)<br>CS 368 (C++) - Fall 2016<br>Adalbert ​Gerald​​ Soosai Raj<br><br><br><br></cslogin></reviewsfile></reviewratingsfile></string,></review></rating></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page79" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/29/page79/">Java代写 A Simple Student Management System</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-29T04:43:26.000Z" itemprop="datePublished" class="post-time">
  2016-12-29
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>完成一个简单的学生管理系统，包括增删改查学信息的功能，保存到数据库，统计和记录学生成绩<br>等等相关操作，输入java入门级的作业<br><br><br><strong>Requirement</strong><br><br>FIT9131 Semester 2 2016 Assignment 2<br>14 September 2016 1<br>A Simple Student Management System<br>Due Date : 12 noon on Friday in Week 12 (21st Oct 2016)<br>Introduction<br>This assignment is worth 25% of the marks for your final assessment in this unit. Heavy penalties will<br>apply for late submission. This is an individual assignment and must be entirely your own work. You must<br>attribute the source of any part of your code which you have not written yourself. Please note the section on<br>plagiarism in this document.<br>The assignment must be done using the BlueJ environment. All user input to the system, and system<br>output to the user, must be done at the BlueJ terminal window. No other graphical interfaces are to be<br>used (nor assessed) in your program.<br>The Java source code for this assignment must be implemented according to the FIT9131 Java Coding<br>Standards.<br>Any points needing clarification should be discussed with your tutor in the tutorial class. You should not<br>make any assumptions about the program without consulting with your tutor.<br>Specification<br>For this assignment you are required to write a program that implements a simple Student Management<br>System for a very small, fictional, school. This section specifies the required functionality of the program.<br>The aim of the Student Management System is for a user (the school’s enrolment staff) to keep a database of<br>the students enrolled in various subjects in this fictional school. This school only offers three (3) subjects :<br>Computing, Maths, and English. The system will allow the user to add/delete students, enrol them in<br>subjects, and perform simple reports.<br>Even though this program is functionally very different from the program you wrote in Assignment 1, you<br>should be able to re-use much of your previous code here - if you have designed the classes/logic in your<br>previous program properly. This is one of the major benefits of an object-oriented program - the ability to<br>re-use classes.<br>The Student Management System should provide the following features :<br> maintains a list (using a Java Collection class) of Student objects<br>o each Student object represents a person who is allowed to enrol in the fictional school<br> maintains a fixed list of exactly 3 Subject objects<br>o each Subject object represents a subject which is available in the fictional school<br>FIT9131 Semester 2 2016 Assignment 2<br>14 September 2016 2<br> enrol each student in a subject, or subjects (HD level)<br> lists the details of an existing student<br> produces a report of students based on some criteria<br> loads a list of students (with their enrolled subjects) from a text file<br> saves the list of current students (with their enrolled subjects) to a text file<br>You are to demonstrate the following programming techniques in your program :<br> reading/writing data from/to text files<br> using appropriate Java Collection class or classes to store data<br> using code to manipulate the data in the collection(s)<br> performing simple searches, filtered by some given criteria<br> using program constructs such as repetitions &amp; selections<br> using appropriate classes to represent objects in the program<br>There will be a description of the “HD level” features later in this document (in the Grades section).<br>You are also required to produce a partial Test Strategy for your program.<br>FIT9131 Semester 2 2016 Assignment 2<br>14 September 2016 3<br>Program Logic<br>When the Student Management System starts, it should automatically load a text file called<br>“students.txt” which contains details of all students currently stored in the system. The actual format<br>of this text file is described later in this document. The data loaded should be stored in some appropriate data<br>structures. No other reading from or writing to file is required while the program is in operation, until the<br>user chooses to exit, at which point the program saves all the data in memory back to the same text file<br>(students.txt).<br>In other words, the file I/O operations are performed automatically by the program, and require no<br>interactions with the user.<br>When the program is running, it should repeatedly display a menu with these options :<br>(1) Add new student<br>(2) Delete a student<br>(3) Find Student By Name<br>(4) List Students By Subject<br>(5) List All Students<br>(6) Exit System<br>Option (1) allows the user to add a new student into the database. The user should be asked for the student’s<br>details, plus what subject to “enrol” him/her in.<br>Option (2) allows the user to remove an existing student from the database.<br>Option (3) allows the user to find an existing student in the database. The user should be asked to enter a<br>name to search for. If a matching student is found, his/her details will be displayed.<br>Option (4) allows the user to display a list of students enrolled in a subject. The user should be asked for a<br>subject name; a list of all students (if any) enrolled in that subject should then be displayed.<br>Option (5) allows the user to display a list of all students enrolled in the school.<br>Option (6) exits the program. All the students currently in memory are automatically saved to<br>“students.txt”.<br>Inputs other than 1-6 should be rejected, and an error message printed. The menu should be displayed<br>repeatedly, until the user chooses Option (6).<br>FIT9131 Semester 2 2016 Assignment 2<br>14 September 2016 4<br>Important Assumptions<br>You should observe the following assumptions when implementing your program :<br> all student names are unique - if a student is already in the database, trying to add the same name<br>again should generate an error<br> there is no limit to how many students can be enrolled<br> exactly 3 subjects are offered : Computing, Maths and English<br> each student can only enrol in exactly one subject<br> all searches use exact matches (eg. “andy” will not match “andy cheng”); however, the search<br>strings are not case-sensitive (eg. “Sue Smith” is considered to be the same as “SUE smith”)<br> the data file is always in the correct format - ie. no need to validate the data when reading it in<br>Student Record Format<br>Each student in the database contains the following information :<br> Name (non-blank String, may contain multiple words)<br> Telephone (non-blank String, exactly 9 digits, 1st digit must be a ‘9’)<br> Subject (a String, representing one of the 3 subjects offered)<br>Input File Format<br>The input data file (students.txt) has the following format for each line :<br>Name,Telephone,Subject  (the fields are separated by commas)<br>Eg.<br>David Smith,912345678,Maths<br>Andy Cheng,987654321,Computing<br>Susan Dally,911221122,English<br>Zak Whatever,999999999,Maths<br>Russell Crowe,980808080,Computing<br>FIT9131 Semester 2 2016 Assignment 2<br>14 September 2016 5<br>Program Design<br>Your program must demonstrate your understanding of the object-oriented concepts and general<br>programming constructs presented in FIT9131. You must use appropriate data structures to store the various<br>objects (list of students, list of subjects, etc) in the program.<br>You must be able to justify the choice of the data structures during your interview. You must document any<br>additional assumptions you made.<br>Validation of values for fields and local variables should also be implemented. You should not allow an<br>object of a class to be set to an invalid state.<br>Discuss with your tutor regarding what classes are appropriate, and how they interact with each other.<br>The main requirements are : (1) the Students and Subjects must be implemented as objects, and they must<br>be stored in some appropriate Java collections, and (2) for the HD level , the list of Subjects within each<br>Student object must also be stored in some appropriate Java collections.<br>Your program must deal with invalid values entered by the user in a sensible manner. For instance, if a user<br>enters “abc” instead of a number for the menu options, your program should not crash.<br>All on-screen input/output should be formatted in a user-friendly manner. Sensible error messages should be<br>displayed whenever appropriate (eg. when searching for a student who is not in the database, trying to enrol<br>student in a subject which does not exist, etc).<br>Grades<br>There are 2 possible Grade Categories for this assignment, as described below :<br>1) A maximum grade of up to a D (Distinction) can be achieved by correctly implementing all the<br>features as described in the “Program Logic” section above.<br>2) To achieve up to a maximum of a HD (High Distinction), you need to implement the following<br>additional features :<br> for Option (1), a student can be enrolled in up to a maximum of 3 unique subjects<br> for Option (4), the user can specify more than 1 subject, and the program will display all<br>students listed in those subjects (eg. all students enrolled in both “Computing” AND “English”,<br>all students enrolled in “Computing” AND “Maths” AND “English”, etc)<br>Note : The description of the program’s logic/design is intentionally left vague, to give you some room<br>to exercise your own design and creativity. Discuss with your tutor about what/how to implement.<br>Important : You must not attempt the HD Category until you have fully implemented the D<br>Category. If you submit a program which partially implements both, you will only be awarded up<br>to a maximum of D.<br>FIT9131 Semester 2 2016 Assignment 2<br>14 September 2016 6<br>Test Strategy<br>For this assignment, you are required to produce a partial Test Strategy for the program.<br>There is no need to produce Test Strategy for any other classes you have used in your program.<br>You must provide a Test Plan, plus detailed sets of Test Data, Expected Results and Actual Results for the<br>Student class.<br>Assessment<br>Assessment for this assignment will be done via an interview with your tutor. The marks will be allocated as<br>follows:<br> Test Strategy : 10%<br> Java Code &amp; Object-Oriented Design : 35%<br> Program Functionality in accordance with the requirements : 55%<br>You must submit your work by the submission deadline on the due date (a late penalty of 20% per day of<br>the possible marks will apply).<br>Marks will be deducted for untidy submissions and non-conformances to the FIT9131 Java Coding<br>Standards.<br>Interview<br>You will be asked to demonstrate your program at an interview following the submission date. At the<br>interview you can also expect to be asked to explain your code, your design, discuss design decisions and<br>alternatives and modify your code as required. Marks will not be awarded for any section of code or<br>functionality that a student cannot explain satisfactorily. (The marker may delete excessive comments in<br>code before a student is asked to explain that code).<br>In other words, you will be assessed on your understanding of the code, and not on the actual code itself.<br>Interview times will be arranged in the tutorial labs in Week 12. It is your responsibility to attend the lab and<br>arrange an interview time with your tutor. Any student who does not attend an interview will receive a mark<br>of 0 for the assignment.<br>The actual interviews will take place in Week 13.<br>Your Test Strategy will be only for one class - the Student class.<br>FIT9131 Semester 2 2016 Assignment 2<br>14 September 2016 7<br>Submission Requirements<br>The assignment must be uploaded to Moodle on or before the due date. The link to upload the assignment<br>will be made available in the Assignments section of the unit’s Moodle site before the submission deadline.<br>The submission requirements are as follows:<br>A .zip file uploaded to Moodle containing the following components:<br> the BlueJ project you created to implement your assignment. The .zip should be named with your<br>Student ID Number. For example, if your id is 12345678, then the file should be named<br>12345678_A2.zip. Do not name your file any other way.<br> it is your responsibility to check that your ZIP file contains all the correct files, and is not corrupted,<br>before you submit it. If you tutor cannot open your zip file, or if it does not contain the correct files,<br>you will not be assessed.<br> an MS Word document containing your Test Strategy for the Student class.  (Note: The JUnit facility in<br>BlueJ is NOT to be used for this assignment)<br> a completed Assignment Cover Sheet. This will be available for download from the unit’s Moodle site<br>before the submission deadline. You simply complete the editable sections of the document, save it, and<br>include it in your .zip file for submission.<br>Marks will be deducted for failure to comply with any of these requirements.<br>Warning : there will be no extensions to the due date. Any late submission will incur the 20% per day<br>penalty. It is strongly suggested that you submit the assignment well before the deadline, in case there are<br>some unexpected complications on the day (eg. interruptions to your home internet connection).<br>Plagiarism<br>Cheating and plagiarism are viewed as serious offences. In cases where cheating has been confirmed,<br>students have been severely penalised, from losing all marks for an assignment, to facing disciplinary action<br>at the Faculty level. Monash has several policies in relation to these offences and it is your responsibility to<br>acquaint yourself with these.<br>Plagiarism (<a href="http://www.policy.monash.edu/policybank/academic/education/conduct/plagiarism-policy.html" target="_blank" rel="external">http://www.policy.monash.edu/policybank/academic/education/conduct/plagiarism-policy.html</a>)<br>Discipline: Student Policy (<a href="http://www.policy.monash.edu/policy-" target="_blank" rel="external">http://www.policy.monash.edu/policy-</a><br>bank/academic/education/conduct/student-discipline-policy.html<br><br><br></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page78" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/28/page78/">Java代写 Programming Assignment 2  Link State Routing</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-28T04:12:34.000Z" itemprop="datePublished" class="post-time">
  2016-12-28
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>java的网络编程，完成状态路由协议，本题主要考察java基础，网络编程基础，设计路由协议，Dijkstra’s算法<br>，UDP套接字协议，动态路由等等知识，分为2个part<br><br><br><strong>Requirement</strong><br><br>COMP 3331/9331: Computer Networks &amp; Applications<br>Programming Assignment 2: Link State Routing<br>Due Date: 28 Oct 2016, 11:59 pm (Week 13) Marks: 10 + 1 bonus<br>1. Change Log<br>Version 1.0 released on 19 th September 2016.<br>2. Goal and Learning Objectives<br>In this assignment your task is to implement the link state routing protocol. Your program will be<br>running at all nodes in the specified network. At each node the input to your program is a set of<br>directly attached nodes (i.e. neighbours) and the costs of these links. Each node will broadcast<br>link-state packets to all other nodes in the network. Your routing program at each node should<br>report the least-cost path and the associated cost to all other nodes in the network. Your program<br>should be able to deal with failed nodes.<br>2.1 Learning Objectives<br>On completing this assignment you will gain sufficient expertise in the following skills:<br>• Designing a routing protocol<br>• Link state (Dijkstra’s) algorithm<br>• UDP socket programming<br>• Handling routing dynamics<br>3. Assignment Specification<br>This section gives detailed specifications of the assignment. You can receive 1 bonus mark for<br>submitting the assignment 1 week prior to the deadline.<br>3.1 Implementation Details<br>In this assignment, you will implement the link state routing protocol.<br>The program will accept the following command line arguments:<br>• NODE_ID, the ID for this node. This argument must be a single uppercase alphabet (e.g., A,<br>B, etc).<br>• NODE_PORT, the port number on which this node will send and receive packets to and from<br>its neighbours.<br>Updates to the assignment, including any corrections and clarifications, will be posted on the<br>subject website. Please make sure that you check the subject website regularly for updates.<br>• CONFIG.TXT, this file will contain the costs to the neighbouring nodes. It will also contain<br>the port number being used by each neighbour for exchanging routing packets. An example of<br>this file is provided below.<br>Since we can’t let you play with real network routers, the routing programs for all the nodes in the<br>simulated network will run on a single desktop machine. However, each instance of the routing<br>protocol (corresponding to each node in the network) will be listening on a different port number.<br>If your routing software executes correctly on a single desktop machine, it should also work<br>correctly on real network routers. Note that, the terms router and node are used interchangeably in<br>the rest of this specification.<br>Assume that the routing protocol is being instantiated for a node A, with two neighbours B and C.<br>A simple example of how the routing program would be executed (assuming it is a Java program<br>named Lsr.java) follows:<br>java Lsr A 2000 config.txt<br>where the config.txt would be as follows:<br>2<br>B 5 2001<br>C 7 2002<br>The first line of this file indicates the number of neighbours (NOT the total number of nodes in the<br>network). Following this there is one line dedicated to each neighbour. It starts with the neighbour<br>id, followed by the cost to reach this neighbour and finally the port number that this neighbour is<br>using for communication. For example, the second line in the config.txt above indicates that the<br>cost to neighbour B is 5 and this neighbour is using port number 2001 for receiving and<br>transmitting link-state packets. The node ids will be uppercase alphabets and you can assume that<br>there will be no more than 10 nodes in the test scenarios. However, do not make assumptions that<br>the node ids will necessarily start from the letter A or that they will always be in sequence. The<br>link costs should be floating point numbers (up to the first decimal) and the port numbers should<br>be integers. These three fields will be separated by a single white space between two successive<br>fields in each line of the configuration file. The link costs will be static and will not change once<br>initialised. Further, the link costs will be consistent in both directions, i.e., if the cost from A to B<br>is 5, then the link from B to A will also have a cost of 5. You may assume that the configuration<br>files used for marking will be consistent with the above description and devoid of any errors.<br>Important: It is worth restating that initially each node is only aware of the costs to its direct<br>neighbours. The nodes do not have global knowledge (i.e. information about the entire network<br>topology) at start-up.<br>The remainder of the specification is divided into two parts, beginning with the base specification<br>as the first part and the subsequent part adding new functionality to the base specification. In order<br>to receive full marks for this assignment you must implement both parts. If you are unable to<br>complete the second part, you will still receive marks for the first part. (The marking guidelines at<br>the end of the specification indicate the distribution of marks).<br>Part 1: Base Specification<br>In link-state routing, each node broadcasts link-state packets to all other nodes in the network, with<br>each link-state packet containing the identities of the node’s neighbours and the associated costs to<br>reach them. You must implement a simple broadcasting mechanism in your program. Upon<br>initialisation, each node creates a link-state packet (containing the appropriate information – see<br>description of link-state protocol in the textbook/lecture notes) and sends this packet to all direct<br>neighbours. The exact format of the link-state packets that you will use is left for you to decide.<br>Upon receiving this link-state packet, each neighbouring router in turn broadcasts this packet to its<br>own neighbours (excluding the router from which it received this link-state packet in the first<br>place). This simple flooding mechanism will ensure that each link-state packet is propagated<br>through the entire network.<br>It is possible that some nodes may start earlier than their neighbours. As a result, a node might<br>send the link-state packet to a neighbour, which has not run yet. You should not worry about this<br>since the routing program at each node will repeatedly send the link-state packet to its neighbours<br>and a slow-starting neighbour will eventually get the information. That said, when we test your<br>assignment, we would ensure that all nodes are initiated simultaneously (using a script).<br>Each node should periodically broadcast the link-state packet to its neighbours every<br>UPDATE_INTERVAL. You should set this interval to 1 second. In other words, a node should<br>broadcast a link state packet every second.<br>Real routing protocols use UDP for exchanging control packets. Hence, you MUST use UDP as<br>the transport protocol for exchanging link-state packets amongst the neighbours. Note that, each<br>router can consult its configuration file to determine the port numbers used by its neighbours for<br>exchanging link-state packets. Do not worry about the unreliable nature of UDP. Since, you are<br>simulating multiple routers on a single machine, it is highly unlikely that link-state packets will be<br>dropped. Furthermore, since link-state packets are broadcast periodically, occasional packet loss<br>will not impact the operation of your protocol. If you use TCP, a significant penalty will be<br>assessed.<br>On receiving link-state packets from all other nodes, a router can build up a global view of the<br>network topology. You may want to review your class notes and consult standard data structures<br>textbooks for standard representations of undirected graphs, which would be an appropriate way to<br>model this view of the network.<br>Given a view of the entire network topology, a router should run Dijkstra’s algorithm to compute<br>least-cost paths to all other routers within the network. Each node should wait for a<br>ROUTE_UPDATE_INTERVAL (the default value is 30 seconds) since start-up and then execute<br>Dijkstra’s algorithm. Given that there will be no more than 10 nodes in the network and a periodic<br>link-state broadcast frequency of 1 second, 30 seconds is a sufficiently long duration for each node<br>to discover the global view of the entire topology.<br>Once a router finishes running Dijkstra’s algorithm, it should print out to the terminal, the least-<br>cost path to each destination node (excluding itself) along with the cost of this path. The following<br>is an example output for node A in some arbitrary network:<br>least-cost path to node B: ACB and the cost is 10<br>least-cost path to node C: AC and the cost is 2.5<br>We will wait for duration of ROUTE_UPDATE_INTERVAL after running your program for the<br>output to appear (some extra time will be added as a buffer). If the output does not appear within<br>this time, you will be heavily penalised. As indicated earlier, we will restrict the size of the<br>network to 10 nodes in the test topologies. The default value of 30 seconds is sufficiently long for<br>all the nodes to receive link-state packets from every other node and compute the least-cost paths.<br>Your program should execute forever (as a loop). In other words, each node should keep<br>broadcasting link-state packets every UPDATE_INTERVAL and Dijkstra’s algorithm should be<br>executed and the output printed out every ROUTE_UPDATE_INTERVAL. To kill an instance of<br>the routing protocol, the user should type CTRL-C at the respective terminal.<br>Restricting Link-state Broadcasts: Note that, a naïve broadcast strategy; wherein each node<br>retransmits every link state packet that it receives will result in unnecessary broadcasts and thus<br>increase the overhead. To elaborate this issue, consider the example topology discussed in the<br>latter part of the spec. The link-state packet created by node A will be sent to its direct neighbours<br>B, C and D. Each of these three nodes will in turn broadcast this link-state packet to their<br>neighbours. Let us consider Node C, which broadcasts A’s link state packet to B, D, E and F. Note<br>that node B has already broadcast A’s link state packet once (when it received it directly from A).<br>Node B has now received this same link-state packet via node C. There should thus be no need for<br>node B to broadcast this packet again. You MUST implement a mechanism to reduce such<br>unnecessary broadcasts. This can be achieved in several ways. You are open to choose any method<br>to achieve this. You must describe your method in the written report.<br>Part 2: Dealing with Node Failures<br>In this part you must implement additional functionality in your code to deal with random node<br>failures. Recall that in the base assignment specification it is assumed that once all nodes are up<br>and running they will continue to be operational till the end when all nodes are terminated<br>simultaneously. In this part you must ensure that your algorithm is robust to node failures. Once a<br>node fails, its neighbours must quickly be able to detect this and the corresponding links to this<br>failed node must be removed. Further, the routing protocol should converge and the failed nodes<br>should be excluded from the least-cost path computations. The other nodes should no longer<br>compute least-cost paths to the failed nodes. Furthermore, the failed nodes should not be included<br>in the least-cost paths to other nodes.<br>A simple method that is often used to detect node failures is the use of periodic heartbeat (also<br>often known as keep alive) messages. A heartbeat message is a short control message, which is<br>periodically sent by a node to its directly connected neighbours. If a node does not receive a<br>certain number of consecutive hearbeat messages from one of its neighbours it can assume that<br>this node has failed. Note that, each node transmits a link-state packet to its immediate neighbour<br>every UPDATE_INTERVAL (1 second). Hence, this distance vector message could also double<br>up as the hearbeat message. Alternately, you may wish to make use of an explicit heartbeat<br>message (over UDP), which is transmitted more frequently (i.e. with a period less than 1 second)<br>to expedite the detection of a failed node. It is recommended that you wait till at least 3 consequent<br>hearbeat (or link-state) messages are not received from a neighbour before considering it to have<br>failed. This will ensure that if at all a UDP packet is lost then it does not hamper the operation of<br>your protocol.<br>Once a node has detected that one of its neighbours has failed, it should update its link-state packet<br>accordingly to reflect the change in the local topology. Eventually, via the propagation of the<br>updated link-state packets, other nodes in the network will become aware that the failed node is<br>unreachable and it will be excluded from the link-state computations (i.e. Dijkstra’s algorithm).<br>Once a node has failed, you may assume that it cannot be initialised again.<br>While marking, we will only fail a few nodes, so that a reasonable connected topology is still<br>maintained. Furthermore, care will be taken to ensure that the network does not get partitioned. In<br>a typical topology (recall that the largest topology used for testing will consist of 10 nodes), at<br>most 3 nodes will fail. However, note that the nodes do not have to fail simultaneously.<br>Recall  that  each  node  will  execute  Dijkstra’s  algorithm  periodically  after<br>ROUTE_UPDATE_INTERVAL (30 seconds) to compute the least-cost path to every other<br>destination. It may so happen that the updated link-state packets following a node failure may not<br>have reached certain nodes in the network before this interval expires. As a result, these nodes will<br>use the old topology information (prior to node failure) to compute the least-cost paths. Thus the<br>output at these nodes will be incorrect. This is not an error. It is just an artefact of the delay<br>incurred in propagating the updated link-state information. To account for this, it is necessary to<br>wait for at least two consecutive ROUTE_UPDATE_INTERVAL periods (i.e. 1 minute) after the<br>node failure is initiated. This will ensure that all the nodes are aware of the topology change.<br>While marking, we will wait for 2<em>ROUTE_UPDATE_INTERVAL following a node failure<br>before checking the output.<br>3.2. An Example<br>Let us look at an example with the network topology as shown in the figure below:<br>The numbers alongside the links indicate the link costs. The configuration files for the 6 nodes are<br>available for download from the assignment webpage. In the configuration files we have assumed<br>the following port assignments: A at 2000, B at 2001, C at 2002, D at 2003, E at 2004 and F at<br>2005. However note that some of these ports may be in use by another student logged on to the<br>same CSE machine as you. In this case, change the port assignments in all the configuration files<br>appropriately. The program output at node A should look like the following:<br>least-cost path to node B: AB and the cost is 2.0<br>least-cost path to node C: ADEC and the cost is 3.0<br>least-cost path to node D: AD and the cost is 1.0<br>least-cost path to node E: ADE and the cost is 2.0<br>least-cost path to node F: ADEF and the cost is 4.0<br>Note: It is not necessary that your program should print the paths to the destinations in<br>alphabetical order.<br>You may also test out the ability of your program to deal with node failures in the above example<br>by causing node B to fail (as an example).<br>Please ensure that before you submit, your program provides a similar output for the above<br>topology. However, we will use different network topologies in our testing.<br>4. Additional Notes<br>This is not a group assignment. You are expected to work on this individually.<br>How to start: Sample UDP client and server programs are available on the Week 3 lecture<br>material page. They are a good starting point to start your development. You will also find several<br>links to network programming resources on that page.<br>A<br>D<br>B  C<br>E<br>F<br>2<br>2<br>5<br>1<br>1<br>1<br>3<br>2<br>5<br>3<br>Language and Platform: You are free to use one of C, JAVA or Python to implement this<br>assignment. Please choose a language that you are comfortable with. The programs will be tested<br>on CSE Linux machines. So please make sure that your entire application runs correctly on these<br>machines. This is especially important if you plan to develop and test the programs on your<br>personal computers (which may possibly use a different OS or version or JVM). Note that CSE<br>machines support the following: gcc version 4.9.2, Java 1.7, Python 2.7, 2.8 and 3. Note for<br>Python: In your report, please indicate which version of Python you have used. You may only use<br>the basic socket programming APIs providing in your programming language of choice. Note that,<br>the network will be simulated by running multiple instances of your program on the same machine<br>with a different port number for each node. Make sure that your program will work appropriately<br>under these conditions. See the sequence of operations listed below for details.<br>Error Condition: Note that all the arguments supplied to the programs will be in the appropriate<br>format. The configuration files supplied as an argument to each node will also be consistent with<br>the test topology. Your programs do not have to handle errors in format, etc.<br>You should be aware that port ID’s, when bound to sockets, are system-wide values and thus other<br>students may be using the port number you are trying to use. On Linux systems, you can run the<br>command netstat to see which port numbers are currently assigned.<br>Do not worry about the reliability of UDP in your assignment. It is possible for packets to be<br>dropped, for example, but the chances of problems occurring in a local area network are fairly<br>small. If it does happen on the rare occasion, that is fine. Further, your routing protocol is<br>inherently robust against occasional losses since the link state packets are exchanged every 1<br>second. If your program appears to be losing or corrupting packets on a regular basis, then there is<br>likely a fault in your program.<br>Test your assignment out with several different topologies (besides the sample topology provided).<br>Make sure that your program is robust to node failures by creating several failed nodes (however<br>make sure that the topology is still connected). You can very easily work out the least-cost paths<br>manually (as shown in the lecture notes or the textbook) to verify the output of your program.<br>5. File Naming Convention and Assignment Submission<br>Your main program should be named Lsr.c (or Lsr.java or Lsr.py). You may of course have<br>additional header files and/or helper files. If you are using C you MUST submit a makefile/script<br>(not necessary with Java and Python). In addition you should submit a small report, report.pdf<br>(no more than 3 pages) describing the program design and a brief description of how your system<br>works. Describe the data structure used to represent the network topology and the link-state packet<br>format. Comment on how your program deals with node failures and restricts excessive link-state<br>broadcasts. Also discuss any design tradeoffs considered and made. Describe possible<br>improvements and extensions to your program and indicate how you could realise them. If your<br>program does not work under any particular circumstances please report this here. Also indicate<br>any segments of code that you have borrowed from the Web or other books.<br>You do not have to submit any topology files.<br>Here are the step-by-step instructions for submission:<br>1. Log in to your CSE account.<br>2. Create a directory called assign and copy ONLY the necessary files into that directory.<br>3. Tar this directory using the following command: “tar –cvf assign.tar assign”<br>4. Submit your assignment using the following command: “give cs3331 assign2 assign.tar”. You<br>should receive a confirmation of your submission.<br>Alternately, you may submit the tar archive via the submission link at the top of the assignment<br>web page.<br>Note that, the system will only accept assign.tar as the file name. All other names will be rejected.<br>You can submit as many times as you like before the deadline. A later submission will override<br>the previous submission, so make sure you submit the correct version. Do not wait till just before<br>the deadline for submission, as there may be unforeseen problems (brief disconnection of Internet<br>connectivity, power outage, computer crash, etc.).<br>Late Submission Penalty: Late penalty will be applied as follows:<br>• 1 day after deadline: 10% reduction<br>• 2 days after deadline: 20% reduction<br>• 3 days after deadline: 30% reduction<br>• 4 days after deadline: 40% reduction<br>• 5 or more days late: NOT accepted<br>NOTE: The above penalty is applied to your final total. For example, if you submit your<br>assignment 2 days late and your score on the assignment is 10, then your final mark will be 10 – 2<br>(20% penalty) = 8.<br>6. Plagiarism<br>You are to write all of the code for this assignment yourself. All source codes are subject to strict<br>checks for plagiarism, via highly sophisticated plagiarism detection software. These checks may<br>include comparison with available code from Internet sites and assignments from previous<br>semesters. In addition, each submission will be checked against all other submissions of the<br>current semester. Do not post this assignment on forums where you can pay programmers to write<br>code for you. We will be monitoring such forums. Please note that we take this matter quite<br>seriously. The LIC will decide on appropriate penalty for detected cases of plagiarism. The most<br>likely penalty would be to reduce the assignment mark to ZERO.<br>That said, we are aware that a lot of learning takes place in student conversations, and don’t wish<br>to discourage you from taking your classmates, provided you follow the Gilligan’s Island Rule -<br>After a joint discussion of an assignment or problem, each student should discard all written<br>material and then go do something mind-numbing for half an hour. For example, go watch an<br>episode of Gilligan’s Island (or Reality TV in modern terms), and then recreate the solutions. The<br>idea of this policy is to ensure that you fully understand the solutions or ideas that the group came<br>up with.<br>It is important, for both those helping others and those being helped, not to provide/accept any<br>programming language code in writing, as this is apt to be used exactly as is, and lead to<br>plagiarism penalties for both the supplier and the copier of the codes. Write something on a piece<br>of paper, by all means, but tear it up/take it away when the discussion is over. It is OK to borrow<br>bits and pieces of code from sample socket code out on the Web and in books. You MUST<br>however acknowledge the source of any borrowed code. This means providing a reference to a<br>book or a URL when the code appears (as comments). Also indicate in your report the portions of<br>your code that were borrowed. Explain any modifications you have made (if any) to the borrowed<br>code.<br>7. Forum Use<br>Students are strongly recommended to discuss about the assignment on the course forum.<br>However, at no point should any code fragments be posted to the message forum. Such actions<br>will be considered to be instances of plagiarism, thus incurring a significant penalty. Students are<br>also encouraged to share example topologies that they have created to test their program.<br>8. Sequence of Operation for Testing<br>The following shows the sequence of events that will be involved in the testing of your<br>assignment. Please ensure that before you submit your code you thoroughly check that your code<br>can execute these operations successfully.<br>1) First chose an arbitrary network topology (similar to the test topology above). Create the<br>appropriate configuration files that need to be input to the nodes. Note again that the<br>configuration files should only contain information about the neighbours and not of the entire<br>topology. Work out the least-cost paths and corresponding costs from each node to all other<br>destinations manually using Dijkstra’s algorithm as described in the lecture notes (or<br>textbook). This will allow you to check that your program is computing the paths correctly.<br>2) Log on to a CSE Linux machine. Open as many terminal windows as the number of nodes in<br>your test topology. Almost simultaneously, execute the routing protocol for each node (one<br>node in each terminal).<br>java lsr A 2000 configA.txt (for JAVA)<br>java lsr B 2001 configB.txt<br>and so on. You may write a simple script to automate this process.<br>3) Wait till the nodes display the output at their respective terminals.<br>4) Compare the displayed paths and costs to the ones obtained in step 1 above. These should be<br>consistent.<br>5) The next step involves testing the capability of your program to deal with failed nodes. For this<br>choose a few nodes (max of 3 nodes) from the topology that is currently being tested (in the<br>above tests) and terminate the nodes by typing CTRL-C in their respective terminal windows.<br>Make sure that the nodes chosen for termination do not partition the network. Work out the<br>least-cost paths from each node to all other destinations manually using Dijkstra’s algorithm as<br>described  in  the  lecture  notes  (or  textbook).  Wait  for  a  duration  of<br>2</em>ROUTE_UPDATE_INTERVAL and observe the updated output at each node. Corroborate<br>the results with the manual computations.<br>6) Terminate all nodes.<br>NOTE: We will ensure that your programs are tested multiple times to account for any possible<br>UDP segment losses (it is quite unlikely that your routing packets will be dropped).<br>9. Marking Policy:<br>We will test your routing protocol for at least 2 different network topologies (which will be<br>distinct from the example provided). Marks will be deducted if necessary, depending on the extent<br>of the errors observed in the output at each node. After the marking process we will upload the test<br>topologies on the website for all students to view.<br>Your code will be marked using the following criteria:<br>• Mechanism to restrict link-state broadcasts: 1 marks<br>• Correct operation of the link state protocol: 5.5 marks<br>• Appropriate handling of dead nodes, whereby the least-cost paths are updated to reflect the<br>change in topology: 2.5 marks<br>• Report: 1 mark<br>Bonus Mark: You may receive 1 bonus mark for submitting the assignment a week before the<br>deadline, i.e. by 21 st October 2016 (Week 12). However, to receive the bonus mark, in addition<br>to submitting by the early deadline, your code should have scored at least 7 marks (out of 10) as<br>per the above criteria. The bonus mark can be used to offset lost marks in any assessable<br>component in this course (e.g. mid-semester exam, final exam, labs, etc.).<br>IMPORTANT NOTE: For assignments that fail to execute all of the above tests, we will be<br>unable to award you a substantial mark. Note that, we will test your code multiple times before<br>concluding that there is a problem. You should test your program rigorously and verify the results<br>by trying out different topologies before submitting your code.<br><br><br><br></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page77" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/27/page77/">C++代写 CS1073  Data Structures and Algorithms</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-27T04:14:52.000Z" itemprop="datePublished" class="post-time">
  2016-12-27
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>本题是实现一个五子棋的游戏，给了部分模板代码，完成五子棋的游戏逻辑，主要考察c++的基础知识和OOP的设计能力，还有数据结构和算法<br>共分了4个task，难度逐渐递增，然后需要通过自动测试<br><br><br><strong>Requirement</strong><br><br>CompSys202/MechEng270<br>Data Structures and Algorithms<br>Assignment #3 (20% of final grade)<br>Due: 11:00am, 21 October 2016<br>Learning outcomes<br>The purpose of this assignment is to target the following learning outcomes:<br>• Demonstrate a basic understanding of C++ development.<br>• Continue to develop and practice your skills in OOP design.<br>• Practice using data structures and algorithms effectively.<br>• Apply good coding practices such as naming conventions and code style.<br>1 Connect Four!<br>The game of Connect Four is described by Wikipedia as follows:<br>[Connect Four] is a two-player connection game in which the players first choose a color and then take turns<br>dropping colored discs from the top into a seven-column, six-row vertically suspended grid. The pieces fall<br>straight down, occupying the next available space within the column. The objective of the game is to connect<br>four of one’s own discs of the same color next to each other vertically, horizontally, or diagonally before your<br>opponent.<br>In this assignment you will construct a simple game of Connect Four. This game will be played between two human<br>players, and will be played until one player wins or a stalemate is reached. A simple demonstration of the Connect<br>Four game is displayed in figure 1.<br>2 Tasks<br>2.1 Player Information [Task 1] (15%)<br>2.1.1 Implement the Player Class<br>The Player class will store information about each player such as their name and color. A player has three<br>properties:<br>• The player’s name, e.g. “Nick”.<br>• The player’s score.<br>• The total number of games won by the player.<br>The player’s name can only be set in the constructor, while the score should be initialized to 0 and can only be<br>increased by 1 or reset using the methods of the Player class. The total number of games won by a player is<br>initialized to zero when the Player is constructed, and then can only be increased by 1.<br>Complete the implementation of the Player class as described in the file Player.hpp by adding code to Player.cpp.<br>1<br>(a) The game is created<br>with a standard 6 row by<br>7 column grid. At the be-<br>ginning of the game the<br>game grid is empty. The<br>top row of the grid is row<br>0 and the left-most col-<br>umn is column 0.<br>(b) The game starts with<br>player one’s turn. In this<br>case player one has in-<br>serted a disc (red) into<br>column 3. The disc falls<br>to the bottom of the grid<br>and stops at row 5.<br>(c) Player two plays their<br>first turn by inserting a<br>yellow disc into column<br>2. The disc falls to the<br>bottom of the grid to<br>come to rest next to the<br>disc placed by player one.<br>(d) Player one plays their<br>next move, placing a red<br>disc in column 4.<br>(e) Player two plays their<br>next move, inserting a<br>yellow disc in column 3.<br>This disc falls towards<br>the bottom of the grid<br>and stops at row 4, where<br>it is stacked on top of the<br>first disc placed by player<br>one.<br>(f) Player one plays their<br>next move, inserting a<br>second red disc into col-<br>umn 4. This disc falls to-<br>wards the bottom of the<br>grid, stacking on top of<br>a previously placed red<br>disc.<br>(g) Player two plays their<br>third move, inserting a<br>yellow disc into column<br>3, where it comes to rest<br>in row 3 on top of two<br>other discs already in-<br>serted into that column.<br>(h) Player one plays their<br>fourth move, inserting a<br>red disc in column 5 that<br>falls to the bottom of the<br>grid (row 5).<br>(i) Player two plays their<br>fourth move by inserting<br>a yellow disc into column<br>4 which stops at row 3<br>due to other discs previ-<br>ously inserted into that<br>column.<br>(j) Player one plays their<br>fifth move, inserting a<br>disc into column 6. This<br>disc falls to the bottom<br>row (row 5) and com-<br>pletes a horizontal row of<br>four red discs. Connect<br>four! Player one wins!<br>Figure 1: A demonstration of the Connect Four game in action.<br>2.1.2 Testing the Player Class<br>Testing code in this assignment works in a similar way to Assignments 1 and 2. When you are ready to test your<br>code, you can compile and run the tests by executing the command make test from the command-line console.<br>The tests for the Player class are already enabled in test.cpp.<br>If you need further information on how to test your code, refer to the testing sections of the assignment briefs<br>for assignments 1 and 2.<br>2.2 Tracking Player Moves [Task 2] (20%)<br>2.2.1 Implement the Grid Class<br>The Grid class is represents the vertically suspended grid into which players insert their colored discs. Each cell<br>of the grid can be represented by a value from the Cell enum declared inside the Grid class. Each cell will either<br>be empty, or hold a disc inserted by one of the two players. The number of cells is determined by the number of<br>rows and columns in the grid, and your Grid class constructor should allow the creation of a game Grid with any<br>size greater than 4 rows by 4 columns. In the case where one of the initialized dimensions is smaller than 4, that<br>dimension should be modified to be exactly 4. For example, if a grid is initialized with 2 rows and 6 columns, it<br>should be automatically corrected to 4 rows and 6 columns inside the Grid constructor.<br>During a game, discs may be inserted into the Grid by either player using the insertDisc method, which takes<br>a Cell value representing the new disc and a column of the grid that the disc should be inserted into. When a disc<br>is inserted into the grid it should be inserted on top of the other discs in the grid, or at the bottom of the grid if<br>there are no other discs in that column. This emulates the physical effect of inserting the disc into the grid in a<br>physical game of Connect Four.<br>To implement the game, other classes will need to be able to access elements in the grid. This information will<br>be accessed using the public cellAt method, which returns a value from the Grid given a specific row and column.<br>This method should return GC_EMPTY for any row or column outside the bounds of the grid. The bounds of the grid<br>2<br>will be returned by the rowCount and columnCount methods.<br>Once the game is over, the game grid needs to be emptied of all inserted player discs so a new game can be<br>started. In the Grid class this is done using the reset method.<br>Complete the implementation for the Grid class in Grid.cpp based on the declarations already created for you<br>in Grid.hpp. Make sure to read the comments above the class and each method in the class for more information<br>on how to implement them properly.<br>2.2.2 Testing the Grid Class<br>The tests for the Grid class can be enabled by uncommenting the following line at the top of test.cpp:<br>// #define ENABLE_T2_TESTS<br>Once the Task 2 tests are enabled, run make test to execute all of the currently enabled tests. Remember that<br>not all aspects of the Grid class may be tested in the tests you have been given, so don’t assume the task is<br>complete once all of the tests pass.<br>2.3 Creating a Connect Four Game [Task 3] (30%)<br>2.3.1 Implement the Game Class<br>The Game class composes the Grid class, aggregates multiple instances of the Player class together and performs<br>the game logic. A game is created using the default constructor for the Game class. The Game’s status method will<br>return GS_INVALID until two Players are assigned to the Game using the setPlayerOne and setPlayerTwo methods<br>and a Grid is assigned using the setGrid method.<br>The game will be executed one turn at a time using the playNextTurn method, with the nextPlayer method<br>providing (read-only) information about which player’s turn it is next. Once the game is complete, the status<br>method will return GS_COMPLETE, and return the winning player via the winner method. Note that if the game is a<br>draw, the winner method will return a null pointer (0), but the Game’s status will still be GS_COMPLETE. If a new<br>game is requested, the state of the current game can be cleared using the restart method.<br>You will need to create code to calculate the status of the game by traversing the grid and identifying 4 or more<br>discs from the same player in a row in any vertical, horizontal or diagonal orientation. Once one player gets at<br>least 4 discs in a row in any direction, they win the game. When a player wins the game, the Game state should<br>be updated accordingly so that the game status is set to GS_COMPLETE and the corresponding Player is returned<br>via the winner method. When a Player wins a game, their score and total number of wins should be increased by<br>1 using the appropriate methods of the Player class (a tie does not count as a win for either player). When the<br>game is restarted (using the restart method), each Player’s score should be reset. The possible directions discs<br>can be connected in to win the game are shown in figure 2 below.<br>(a) A vertical connect-four<br>for the red player (player<br>one).<br>(b) A horizontal connect-<br>four for the red player<br>(player one).<br>(c) A diagonal-up connect-<br>four for the red player<br>(player one).<br>(d) A diagonal-down<br>connect-four for the yellow<br>player (player two).<br>Figure 2: Completed games showing a winning combination in each possible direction. The winning combination<br>of discs has been highlighted in each example.<br>Complete the implementation for the Game class in Game.cpp based on the declarations already created for you<br>in Game.hpp. Make sure to read the comments above the class and each method in the class for more information<br>on how to implement them properly.<br>2.3.2 Testing the Game Class<br>The tests for the Game class can be enabled by uncommenting the following line at the top of test.cpp:<br>3<br>// #define ENABLE_T3_TESTS<br>Once the Task 3 tests are enabled, run make test to execute all of the currently enabled tests. Remember that<br>not all aspects of the Game class may be tested in the tests you have been given, so don’t assume the task is<br>complete once all of the tests pass.<br>2.4 Super Connect Four [Task 4] (15%)<br>In this task you will implement a variant of the classic Connect Four game we will call “Super Connect Four”. In<br>this variant of the game when a player connects four or more discs in a row, those discs will be removed from the<br>grid. This will cause any discs above the removed discs to move down to fill the space in the grid left by the removal<br>of the connected discs. One point will be added to the score of the player who connected the discs. If another line<br>of four or more discs belonging to one player exists after all affected discs have been moved, then this process is<br>repeated. This process continues until the grid reaches a stable state where no more lines of four discs exist and no<br>more cells need to be moved. One turn of such a game is demonstrated in figure 3.<br>(a) The initial game<br>board state for this<br>example. Both<br>players have already<br>made several moves.<br>(b) Player two plays<br>the next move, form-<br>ing a chain of four<br>discs horizontally in<br>row 3. Player two’s<br>score is increased by<br>1.<br>(c) The connected<br>discs are removed<br>from the game grid,<br>leaving blank spaces<br>in the grid.<br>(d) The remaining<br>discs above the ones<br>that were removed<br>are moved down<br>vertically to fill<br>the empty space in<br>the grid. Moving<br>the discs forms two<br>new chains of discs<br>belonging to player<br>one.<br>(e) The grid is<br>scanned, and two<br>new chains belong-<br>ing to player one are<br>found. Player one’s<br>score is increased by<br>1 and the discs are<br>removed from the<br>grid.<br>(f) The disc that was<br>above the removed<br>discs is moved to<br>the bottom of the<br>grid. The grid is re-<br>scanned but no new<br>chains of discs have<br>been formed and no<br>discs need to be<br>moved down. Player<br>two’s turn ends.<br>Figure 3: A demonstration of one turn in the “Super Connect Four” game.<br>The process for each turn of the game should be as follows:<br>1. Make the player’s move by inserting their token into the grid.<br>2. Check to see if any chains of 4 or more discs in any direction have been formed.<br>3. Increase the score by 1 for any players whose discs have formed chains of 4 or more. Each player’s score may<br>only increase by 1 each time the grid is checked (even if players get multiple simultaneous chains in a single<br>check).<br>4. Remove all discs in all chains from the grid.<br>5. Fill all spaces in the grid created in the previous step by moving the discs above the spaces down.<br>6. Repeat from step 2 until no more chains of discs are found and the grid has reached a stable state.<br>Make sure that disc the disc removal and movement steps are fully completed before the grid is re-scanned. Failing<br>to do so may cause additional matches while the grid is still between stable states. This is important for scenarios<br>such as those shown in figure 4 and figure 5.<br>Just as in normal Connect Four, players take alternating turns until the game is complete. This game will end<br>once there is no more space in the grid for either player to insert discs. The winner is the player with the highest<br>score at the end of the game.<br>4<br>(a) The initial game<br>board state for this ex-<br>ample. Both players<br>have already made sev-<br>eral moves.<br>(b) Player one plays the<br>next move, forming a<br>chain of four discs hori-<br>zontally in row 2 as well<br>as a diagonal chain of<br>four discs. Player one’s<br>score is increased by 1.<br>(c) The connected discs<br>are removed from the<br>game grid, leaving blank<br>spaces in the grid.<br>(d) The remaining discs<br>above the ones that<br>were removed are moved<br>down vertically to fill the<br>empty space in the grid.<br>The grid is stable, so<br>this is the end of player<br>one’s turn.<br>Figure 4: A demonstration of a turn in the “Super Connect Four” game where multiple chains of discs are formed<br>for a player in the same move.<br>(a) The initial game<br>board state for this ex-<br>ample. Both players<br>have already made sev-<br>eral moves.<br>(b) Player one plays the<br>next move, forming a<br>chain of four discs hori-<br>zontally in row 5. Player<br>one’s score is increased<br>by 1.<br>(c) The connected discs<br>are removed from the<br>game grid, leaving blank<br>spaces in the grid.<br>(d) The remaining discs<br>above the ones that<br>were removed are moved<br>down vertically to fill the<br>empty space in the grid.<br>Moving the discs forms<br>new chains of discs for<br>both players.<br>(e) The grid is scanned,<br>and new chains belong-<br>ing to both players are<br>found. Both player’s<br>scores are increased by<br>1 and the discs are re-<br>moved from the grid.<br>There are no more discs<br>to move down. Player<br>one’s turn ends.<br>Figure 5: A more complex example of the behavior of the “Super Connect Four” game.<br>2.4.1 Implement the SuperGame class<br>Implement the SuperGame class in SuperGame.hpp and SuperGame.cpp by deriving from the Game class, therefore<br>reducing the amount of code you need to write by inheriting some of the functionality of the Game class. The<br>SuperGame class should use the interface defined by the Game class so that it can be substituted in place of the Game<br>class to provide a new game experience with the same user interfaces.<br>The scoring for the SuperGame is different to the original Game class. When a player gets a chain of four discs<br>their score still increases by 1. However, the game does not end until the game grid has been filled, so the “winner”<br>of the game is determined by the Player with the highest score once the game grid has been filled and no more<br>moves can be played. Once the game is over the winner has their win counter increased by 1. Both player’s scores<br>are still reset when the game is restarted.<br>2.4.2 Testing the SuperGame class<br>The tests for the SuperGame class can be enabled by uncommenting the following line at the top of test.cpp:<br>// #define ENABLE_T4_TESTS<br>Once the Task 4 tests are enabled, run make test to execute all of the currently enabled tests. Remember that<br>not all aspects of the SuperGame class may be tested in the tests you have been given, so don’t assume the task<br>is complete once all of the tests pass.<br>You have also been given a command-line interface (main.cpp) which can be used for advanced testing of your<br>5<br>code by playing a Connect Four or Super Connect Four game. To build and run the command-line interface, use<br>the command make run from the command-line console.<br>You may share any tests you write for this assignment with classmates on Piazza.<br>2.5 Code Inspection (20%)<br>Your code will be inspected for:<br>• Effective use of OOP<br>• Consistent coding style<br>• Code commenting<br>• Memory management<br>Marks will be allocated for each by your marker.<br>Important: how your code will be marked<br>• Your code will be marked using a semi-automated setup. If you fail to follow the setup given, your code will<br>not be marked. All submitted files must compile without requiring any editing. Use the provided tests and<br>Makefile to ensure your code compiles and runs without errors on the university Ubuntu lab PCs. Any tests<br>that run for longer than 10 seconds will be terminated and will be recorded as failed.<br>• Although you may add more to them (e.g. member variables, #include statements, or helper functions), you<br>must not modify the existing interface of classes defined in the following files (e.g. do not delete or modify<br>the existing functions declared):<br>– ConnectFour/Player.hpp<br>– ConnectFour/Grid.hpp<br>– ConnectFour/Game.hpp<br>• Do not move any existing code from the ConnectFour directory, and make sure all of your new code files are<br>created inside the ConnectFour directory.<br>• You may modify test.cpp as you please (for your own testing purposes); this file will not be marked at all.<br>Be aware that your code must still work with the original test.cpp. Do not change the location of this file.<br>You are free to share any additional tests you create with classmates on Piazza.<br>• Your code will also be inspected for good programming practices, particularly using good object-oriented<br>principles. Think about naming conventions for variables and functions you declare. Make sure you comment<br>your code where necessary to help the marker understand why you wrote a piece of code a specific way, or<br>what the code is supposed to do. Use consistent indentation and brace placement.<br>Submission<br>You will submit via Canvas. Make sure you can get your code compiled and running with test.cpp (make test) on<br>the university Ubuntu computers. Submit the following, in a single ZIP archive file:<br>• A signed and dated declaration stating that you worked on the assignment independently, and that it is<br>your own work. Include your name, ID number, the date, the course and assignment number. You can find<br>this Cover Sheet on Canvas. All code will be checked against other submissions. Submissions detected as<br>being similar to others will ensure that the students involved are forwarded to the Misconduct Committee.<br>• The entire contents of the src_for_students folder you were given at the start of the assignment, including<br>the new code you have written for this assignment. Ensure you execute make clean before zipping the<br>folder so your submission doesn’t include any executable files (your code will be re-built for marking).<br>6<br>Academic honesty<br>• The work done on this assignment must be your own work. Think carefully about any problems you come<br>across, and try to solve them yourself before you ask anyone for help. Under no circumstances should you<br>take or pay for an electronic copy of someone else’s work.<br>• All submitted code will be checked using software similarity tools. Submissions with suspicious similarity will<br>result in an Investigative Meeting and will be forwarded to the Disciplinary Committee.<br>• Penalties for copying will be severe – to avoid being caught copying, don’t do it.<br>• To ensure you are not identified as cheating you should follow these points:<br>– Always do individual assignments by yourself.<br>– Never show or give another person your code.<br>– Never put your code in a public place (e.g. Reddit, Github, forums, your website).<br>– Never leave your computer unattended. You are responsible for the security of your account.<br>– Ensure you always remove your USB flash drive from the computer before you log off.<br>Late submissions<br>Late submissions incur the following penalties:<br>• 15% penalty for zero to 24 hours late<br>• 30% penalty for 25 to 48 hours late<br>• 100% penalty for over 48 hours late<br>You must double check that you have uploaded the correct code for marking! There will be no exceptions<br>if you accidentally submitted the wrong files, regardless of whether you can prove you did not modify them since<br>the deadline. No exceptions.<br>7<br><br><br><br></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page76" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/26/page76/">Java代写 CS1073  Assignment 3</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-26T05:24:42.000Z" itemprop="datePublished" class="post-time">
  2016-12-26
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>总共有2个part，第一个part是完成client类的机构methods方法，然后在main函数测试，主要考察java基础能力和单元测试<br>part2是完成3个类。重复使用client类，然后新家一个 Book class和BookStore class。类似一个book管理系统，比part1稍微工作<br>量多一些，也输入java入门知识<br><br><br><strong>Requirement</strong><br><br>CS1073  Assignment 3  Due: 8:30am October 4, 2016 in the Lab or any<br>time prior to 8:15am in the assignment bin.<br>Part 1. Write a program to implement a class called Client that contains the values: name,discount and cumulative<br>purchase amount. Supply an appropriate constructor and methods as described below:<br>•  getName: returns the clients name<br>•  addPurchase: accepts the current purchase amount as a parameter and adds it to the cumulative purchase<br>amount<br>•  getPurchase: returns the cumulative purchase amount<br>•  setDiscount: sets the client’s discount to a specified percentage<br>•  getDiscount: returns the client’s discount<br>•  resetClient: resets the discount percentage and the cumulative purchase amount of the client to zero<br>•  The constructor: accepts one parameter (name) and sets the discount and cumulative amount to zero.<br>Write a main method in a driver class called TestClient to test the Client class. It should have the following functionality:<br>•  Prompt the user for the name of the client and create the client (set the client’s discount and cumulative<br>purchase amount to zero).<br>•  Prompt the user for a discount percentage for the client and update the client’s discount. Read the discount<br>percentage as an integer.<br>•  The client makes a purchase. Prompt the user for the total amount of the current purchase before her/his<br>discount. Apply the client’s discount to the purchase amount. Remember that the client’s discount has been<br>stored as an integer, so to use it as a percentage you need to divide it by 100.00.<br>•  Print the total amount to be paid by the client after her/his discount.<br>•  Update the cumulative purchase amount of the client by adding the purchase amount after applying the<br>discount.<br>•  The client gets a new discount for being a good client. Prompt the user for the new discount, and update it in<br>the client’s information.<br>•  The client makes another purchase. Prompt the user for the total amount of the current purchase before<br>discount. Apply the client’s discount and print the total to be paid after the discount.<br>•  Update the client’s cumulative purchase amount by adding the total payment after discount,<br>•  Print the client’s information (name, discount, cumulative purchase).<br>•  The store is starting a new selling season, the Christmas season. For this season reset the percentage discount<br>and cumulative purchase amount to zero. Print the client’s information (name, discount, cumulative purchase).<br>•  Test your program for a client named Monique Levesque. She initially gets a 5% discount. In her first purchase,<br>she spends $245.99 before any discount. Her new discount for being a good client is 25%. She makes another<br>purchase of $60.00 before any discount.<br>Print all amounts rounded to two decimal places.<br>Part 2 In this part of the assignment you are going to use three classes. You are going to reuse the Client class that you<br>implemented above, and implement two new classes: a Book class and a BookStore class. The BookStore class is the<br>driver class for the Client and Book classes.<br>For the implementation of the Book class use the following guidelines. A book has a title, a price, and a discount. There<br>are four methods (getTitle. getPrice. setPrice. getDiscount) as well as two constructors as described below:<br>•  getTitle: returns the title of the book.<br>•  getPrice: returns the current price of the book.<br>•  setPrice: changes the price to a specified amount.<br>•  getDiscount: returns the current discount for the book.<br>First constructor: accepts two parameters (title and price) and sets the title and price while setting the discount<br>percentage to 0% (i.e. this book has no discount).<br>Second constructor: accepts three parameters (title. price and the discount percentage) and sets them all accordingly.<br>Write the BookStore class that uses the Client and Book classes. The main method of the BookStore class should have<br>the following functionality:<br>•  Prompt the user for the first book (Title: HTML for the World Wide Web, Price: 24.95, Percentage Discount: 5%)<br>and create the corresponding book object.<br>•  Read the discount percentage as an integer.<br>•  Prompt the user for the second book (Title: Operating Systems. Price: 69.95). Do not prompt for the percentage<br>discount; let the class initialize it for you. Create the corresponding book object.<br>•  Change the price of the HTML book to $30.00.<br>•  Now create a client: Andrea Smith.<br>•  Set Andrea’s percentage discount to 15%.<br>•  Andrea buys the two books mentioned above. Print an invoice for Andrea. Obtain the cost of each book after<br>applying the individual book discount. Then. apply the client’s discount to the total cost of the books. Remember<br>that the discount values are integers and you have to divide them by 100.00 when you need to use them as a<br>percentage. The format of the invoice should be as follows<br>Andrea Smith<br>$ 28.50 HTML for the World Wide Web<br>$ 69.95 Operating Systems<br>————–<br>$ 98.45 subtotal<br>$ 14.77 Client’s Discount<br>————<br>$ 83.68 Total<br>•  Update Andrea’s client information with the cumulative purchase amount.<br>•  Print Andrea’s information (name, discount, cumulative purchase).<br>•  Print all amounts rounded to two decimal places.<br>Summary:<br>You will have 2 class files: Client &amp; Book<br>You will have 2 driver files: TestClient &amp; Bookstore<br><br><br><br></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page75" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/25/page75/">C代写 Assignment 3</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-25T04:14:42.000Z" itemprop="datePublished" class="post-time">
  2016-12-25
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>c语言实现还一个Nim的游戏，需要使用很多数据结构，trees, linked-lists, and stack等等完成人机对战版本<br><br><br><strong>Requirement</strong><br><br>1/4<br>KIT107 Programming  2016<br>Assignment 3<br>Due Date<br>The assignment is due at 3PM Wednesday October 12 th 2016 and should be completed in pairs.<br>Context<br>Nim is a game played between two players. 21 objects (matches, coins, or lollies) are placed in<br>front of the players and, having decided who will go first, each player removes one, two, or three<br>objects in alternating turns. The goal is to force the other player to remove the final object — the<br>player to remove the final object is the loser!<br>This assignment uses many data structures (trees, linked-lists, and stacks) to implement a human-<br>versus-computer version of the game. The game will be text only. The computer will choose its<br>move by creating a game tree. A game tree consists of all the possible states of the game and the<br>computer determines the outcome of particular choices to guide which choice is the best. The state<br>of the game is defined as comprising how many objects remain in the game and how good (or bad)<br>the outcome looks (an int from -9 to +9). Each node of the game tree has children that indicate<br>the states of the game that follow from the state of the parent for each possible move, i.e. there are<br>likely to be three children for each node, one with one additional object removed, one with two, and<br>one with three.<br>2/4<br>A sample run of the game is shown below.<br>The project contains many files. All required files are present. Your task is simply to complete the<br>functions within the program files which have been declared but for which the function bodies are<br>missing.<br>Program Style<br>Your program should follow the following coding conventions:<br>  const variable identifiers should be used as much as possible, should be written all in<br>upper case and should be declared before all other variables;<br>  Variable identifiers should start with a lower case letter;<br>  Every if and if-else statement should have a block of code (i.e. collections of lines<br>surrounded by { and }) for both the if part and the else part (if used);<br>  Every loop should have a block of code;<br>  The keyword continue should not be used;<br>  The keyword break should only be used as part of a switch statement;<br>  Opening and closing braces of a block should be aligned;<br>  All code within a block should be aligned and indented 1 tab stop (or 4 spaces) from the<br>braces marking this block;<br>  Commenting:<br>o  There should be a block of header comment which includes at least<br>  file name<br>  student names<br>  student identity numbers<br>  a statement of the purpose of the program<br>  date<br>o  Each variable declaration should be commented<br>o  There should be a comment identifying groups of statements that do various parts of<br>the task<br>3/4<br>o  Comments should describe the strategy of the code and should not simply translate<br>the C into English<br>What and how to submit<br>What to submit<br>Paper submission<br>  A signed cover page (blanks can be collected from the ICT Reception/Help Desk or from<br>the ICT web site at<br><a href="http://www.utas.edu.au/__data/assets/pdf_file/0005/161375/GroupAssignmentCover.pdf" target="_blank" rel="external">http://www.utas.edu.au/__data/assets/pdf_file/0005/161375/GroupAssignmentCover.pdf</a>);<br>  A landscape-orientation print-out of the three ‘.c’ source code files for the program. Your<br>assignment will not be marked unless these are present; and<br>  A statement from each person indicating what proportion of the work was theirs. If the<br>work was done equally, then each person should claim 50% of the effort. It is expected that<br>this will be the case and this will be assumed if no statement is submitted. If, however, one<br>person has done very little, then this should be stated. A reason why this is the case should<br>be given. For example, if one student does 80% of the work because their partner did not<br>turn up to meetings, complete work by the agreed time, etc. then this should be stated. If<br>one student does 30% of the work because the other student simply went off and did it all by<br>themselves and without consultation then this should be stated.<br>Electronic submission<br>  You should submit the entire Visual Studio project folder.<br>How to submit<br>Paper submission<br>  Firmly staple together all of the required documents (with the signed cover page on top) and<br>place them in the appropriate submissions box near the ICT Discipline Help Desk.<br>Electronic submission<br>  Go to your home directory on alacritas (M:). You will find there a directory (folder) called<br>kit107submit (If you do not have this folder, please contact the ICT Discipline Help<br>desk.)<br>  Copy your entire Visual Studio project folder (Assig3) into this directory. Open the folder<br>to see that the files have been copied.<br>  If you want to resubmit, open the kit107submit folder, remove the old version and copy<br>in the new version.<br>4/4<br>Marking scheme<br>Task/Topic  Maximum<br>mark<br>Program operates as specified<br>node.c correctly completed  6<br>stack.c correctly completed  6<br>gameState.c correctly completed  7<br>tNode.c correctly completed  14<br>gameTree.c correctly completed  31<br>Program Style<br>Does not unnecessarily repeat tests or have other redundant/confusing code  8<br>Uses correctly the C naming conventions  8<br>Alignment of code and use of white space makes code readable  8<br>Always uses blocks in branch and loop constructs  8<br>Meaningful identifiers  8<br>Variables declared at the top of functions  8<br>Each variable declaration is commented  8<br>Comments within the code indicate the purpose of sections of code (but DO NOT just duplicate<br>what the code says)<br>8<br>Plagiarism and Cheating:<br>Practical assignments are used by the School of Engineering and ICT for students to both reinforce<br>and demonstrate their understanding of material which has been presented in class. They have a<br>role both for assessment and for learning. It is a requirement that work you hand in for assessment<br>is substantially your own.<br>Working with others<br>One effective way to grasp principles and concepts is to discuss the issues with your peers and/or<br>friends. You are encouraged to do this. We also encourage you to discuss aspects of practical<br>assignments with others. However, once you have clarified the principles, your pair must express<br>them in writing or electronically entirely by yourselves. In other words you must develop the<br>algorithm to solve the problem and write the program which implements this algorithm with your<br>partner and no one else (other than staff).<br>Cheating<br>  Cheating occurs if you claim work as your own when it is substantially the work of someone<br>else.<br>  Cheating is an offence under the Ordinance of Student Discipline within the University.<br>Furthermore, the ICT profession has ethical standards in which cheating has no place.<br>  Cheating involves two or more parties.<br>o  If you allow written work, computer listings, or electronic version of your code to be<br>borrowed or copied by another student you are an equal partner in the act of<br>cheating.<br>o  You should be careful to ensure that your work is not left in a situation where it may<br>be stolen by others.<br>  Where there is a reasonable cause to believe that a case of cheating has occurred, this will<br>be brought to the attention of the unit lecturer. If the lecturer considers that there is evidence<br>of cheating, then no marks will be given to any of the students involved. The case will be<br>referred to the Head of School for consideration of further action.<br>Julian Dermoudy, September 21 st 2016.<br><br><br></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page74" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/24/page74/">C++代写： Computer Networks Fall 2016</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-24T10:24:42.000Z" itemprop="datePublished" class="post-time">
  2016-12-24
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>用UDP和TCP套接字，完成一个简单的“黑客”游戏，有客户端和服务端，服务端生成密码，客户端猜测并且发送给<br>服务端验证，需要运用到了网络知识和c++知识<br><br><strong>Requirement</strong><br><br>CSE422 Computer Networks Fall 2016<br>Laboratory 1: Introduction to Socket Programming<br>Due: 23:59 Monday, Oct 3<br>1 Goal<br>Gain experience with socket programming by implementing a simple “hacker” game using<br>both UDP and TCP sockets. In this game, one participant tries to guess a four-digit password<br>known to the other participant, receiving feedback on each guess as described below.<br>2 Overview<br>In this lab, you will implement a networking version of the hacking mini game, which will<br>comprise of two C++ programs, one client and one server. This lab will help you to gain<br>experience with socket programming using Berkeley socket interface. In order to focus more<br>on the details of socket programming part, the game and most of the command parsing are<br>provided as a skeleton code.<br>This lab is worth for 60 points. This lab is due no later than 23:59 Monday, Oct 3. No late<br>submission will be accepted.<br>3 Specification<br>In this lab, you are required to implement a client and a server program for the ”hacker”<br>game. The server program and client program will interact by exchanging messages to<br>simulate the game play. A simple message/packet format is provided in the file: message.h.<br>The server and client program will handshake through TCP and the gaming interaction will<br>use UDP.<br>3.1 “Hacker” Game<br>The game will display a list of possible passwords (formatted in a way to mimic what is seen<br>in the Fallout game series). The user will then enter a guess for which one they believe the<br>password to be. The game will report back the “likeness” of the guess (how many correct<br>letters are in the correct position).<br>1<br>For example, suppose the password is ”FULL” and the displayed text, containing all of the<br>possible passwords, is:<br>ROBCO INDUSTRIES (TM) TERMALINK PROTOCOL<br>ENTER PASSWORD NOW<br><br>The default number of attempts is set to 4.<br>A demo of the ”hacking” game play can be found at: [Demo Play]<br>-In the demo, click the power button in the right lower corner then click on the phase that<br>you would like to guess as the password.<br>3.2 The Server Program<br>Example invocation: ./server<br>The server program will create a TCP socket and will then wait for an incoming TCP<br>connection. This TCP socket’s port will be assigned by the operating system and will be<br>printed to the console. We assume that the client knows this TCP port number, because the<br>client is started after the server. When the server receives an incoming TCP connection, it<br>creates a UDP socket, whose port is also assigned by the OS. Via the TCP socket, the server<br>program returns a packet to the client containing the UDP port number. This can be done<br>using the UDP Cntr MSG type found in message.h.<br>Once the UDP connection is established, the server program initializes a variable of type<br>HackerGame. The initialization of this variable generates the server password, a list of<br>possible passwords, a string to act as the display board for the game, and the number<br>of attempts left. These are accessible through functions in the HackerGame class. We<br>recommend that you look over HackerGame.h. Guesses from the client can be evaluated by<br>2<br>using the TestEntry() function. The server keeps receiving and testing guesses from the<br>client until either the number of attempts has been exhausted or the password is guessed<br>correctly. For each guess, the server sends a packet containing the “Likeness” of the guess<br>to the client using the UDP socket. Once the game is over, either by guessing the password<br>correctly or running out of attempts, the server must notify the client using the UDP socket,<br>after which the server closes both the TCP and UDP sockets.<br>3.3 The Client Program<br>Example invocation: ./client -h lenny.cse.msu.edu -p 48192<br>The client program is required to accept the following arguments.<br>• -h is the server address (domain name).<br>• -p is the TCP port number on which the server listens for an incoming connection.<br>The client resolves the server address by using gethostbyname() and connects to the server<br>over TCP. The client then receives a packet from the server containing the UDP port number.<br>Using the UDP port number, the client sends a confirmation message to the server, letting<br>it know that it can send the first game message, using the UDP socket. The client receives a<br>packet containing the game display text and prints it to console. The client then takes input<br>from the user for the a guess at the password and sends the guess to the server program via<br>the UDP socket. For each guess the client should receive a response containing the likeness<br>of the guess and how many attempts are left. These are to be printed to console.<br>The client should monitor the content of each game message for ending conditions. Specif-<br>ically, if AttemptsLeft = 0 or IsGameWon = true, then the client should print to console<br>either “Terminal Locked Out!” or”Access Granted!”, respectively. The client then closes<br>both the TCP and UDP sockets.<br>3.4 Packet Format: message.h<br>There are two different types of packets for this lab; both are defined in message.h.<br>1. UDP Cntr MSG: which contains only one field: int port<br>2. Game MSG: which contains:<br>(a) char Display[1000]<br>(b) int AttemptsLeft<br>(c) bool IsGameWon<br>(d) int Likeness<br>3<br>(e) char Entry[10]<br>String type variables cannot be used in these packets due to how they utilize memory. For<br>information to be correctly sent in packets, the packet most know the starting address of the<br>variable and how large it is. Hence why we use arrays of chars.<br>You may want to still use strings in your client and server programs, however. Following are<br>two examples of copying content between the two variable types.<br>Copying char array to a string:<br>char Word1[10] = “test”;<br>string Word2(Word1); //Word2 now contains “test”<br>Copying a string to a char array:<br>string Word2 = “test”;<br>char Word1[10];<br>strcpy(Word1, Word2.c str()); // Word1 now contains “test”<br>4 Deliverables<br>You will submit your lab using the web based handin utility. Don’t use the command-line<br>based handin facility. Please submit all files in your project directory. If you start your lab<br>with the skeleton code, submit all files, even if the file is not modified.<br>This lab is due no later than 23:59 Monday, Oct 3. No late submission will be accepted.<br>The compilation must be done using a makefile. The code should compile on multiple<br>machines (can use lenny, carl, bart, etc). Please do not do your debugging on the servers<br>(arctic or black). You will not be awarded any points if your submission does not compile<br>using a makefile. A sample makefile will be provided. It will only have to be changed if you<br>add more files to your solution. Please test your programs before handing them in.<br>A README file is required including your name, PID, and machines that you tested on.<br>You will run your server and client programs and paste the output in your README file.<br>A sample README file is also included in the skeleton code. You are also encouraged to<br>include explanations about parts of your code that may not work in the README file.<br>5 Example<br>Follows is an example of output from the client and server. Your output may differ.<br>1. Invoke the server<br>4<br>Server:<br>&gt;./server<br>Creating TCP Socket…<br>TCP socket has port number: 53401<br>2. Invoke the client. The client connects to the server using the TCP connection infor-<br>mation that you provide via the command line.<br>Client:<br>&gt;./client -h lenny.cse.msu.edu -p 53401<br>Client is running…<br>remote host: lenny.cse.msu.edu, remote TCP port: 53401<br>Connected to Server!<br>3. Server accepts the TCP connection from the client and sends the UDP port information<br>using the TCP connection.<br>Server:<br>A new client is connected to the server!<br>Creating UDP Socket…<br>UDP socket has port number: 32471<br>Sending UDP port number to client using TCP connection…<br>4. Client uses the message from the TCP connection to establish an UDP port.<br>Client:<br>Reading TCP socket for UDP set up info…<br>UDP port on Server: 32471<br>Server IP: 35.9.23.42<br>Establishing UDP Connection…<br>5. Once the UDP connection is established, the server starts the game and accepts guesses<br>from the client until either the password is guessed or the number of attempts is<br>exhausted. Optionally the server can display the password for debugging purposes.<br>Server:<br>Password: FOUR<br>Starting game…<br>Entry: term<br>Likeness: 0<br>Entry: ball<br>Likeness: 0<br>Entry: year<br>Likeness: 1<br>Entry: four<br>Likeness: 4<br>Access Granted!<br>Closing TCP and UDP sockets…<br>5<br>Client:<br>Receiving first game message…<br>ROBCO INDUSTRIES (TM) TERMALINK PROTOCOL<br>Entry: term<br>Likeness: 0<br>Attempts left: 3<br>Entry: ball<br>Likeness: 0<br>Attempts left: 2<br>Entry: year<br>Likeness: 1<br>Attempts left: 1<br>Entry: four<br>Access Granted!<br>Closing TCP and UDP sockets…<br>6 Grading<br>You will not be awarded any points if your submission does not compile.<br>Please feel free to mail TA Glen Simon simongle AT msu.edu for questions or clarifications.<br>Additional notes and FAQ willl be posted on the website as well.<br>7<br><br></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>

</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-page73" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/12/23/page73/">Java代写： Assignment 1, prepared by Chris Trathen</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-12-23T07:28:43.000Z" itemprop="datePublished" class="post-time">
  2016-12-23
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <font size="4"><br><strong>Introduction</strong><br>5个java的基础题，考察了操作符运算，数组，时间等基础知识，输入入门级编程<br><br><strong>Requirement</strong><br><br>CSE105 CW1  1<br>CSE105 Introduction to Programming in Java, 2016<br>Assignment 1, prepared by Chris Trathen<br>Instruction<br>(1) There are 5 questions for the first assignment. Each question is worth 20 marks. The<br>assignment is worth 15% of the total mark for CSE105.<br>(2) Plagiarism will be very closely monitored. You should be very cautious when you discuss<br>with classmates. Two similar answers will all get zeros marks or more serious consequences.<br>After the marking, some of the students will be interviewed to confirm their independence in the<br>completion of the assignments.<br>(3) The deadline for submission of Assignment 1 is: 6:00pm, October 16, 2016 Sunday. You<br>should pack all of your code with WinRAR, using your student ID as the file name and then<br>upload it to ICE. The uploading link will be automatically stopped after 6:00pm.<br>Question 1<br>The factorial function of a positive integer n is the product of all the integers from 1 to n. For<br>example, the factorial of 5 is 1x2x3x4x5 = 120. This is usually expressed as 5!=120. By<br>definition 0!=1. Write a program that calculates the factorial n!.<br>Write a program that accepts as input a number between 0 and 20 and calculates the factorial of<br>that number.<br>Question 2<br>Write a program that prints a table of temperature conversion from Celsius to Fahrenheit. For<br>example:<br>Celsius  Fahrenheit<br>100  212<br>5  41<br>…………<br>-5  23<br>The exact range of data used is your choice. This is example only.<br>Use the formula F = C <em> 9 / 5 + 32<br>Perform the calculation using floating point arithmetic, but display the results as the closest<br>integer.<br>CSE105 CW1  2<br>Question 3<br>Write a program that analyses a triangle. Input the length of 3 sides of a triangle from the<br>keyboard.<br>Firstly, reject any input that does not represent a triangle.<br>Then determine whether the triangle is:<br> Equilateral - all sides the same length<br> Isosceles - two sides the same length<br> Scalene - no sides the same length<br>CSE105 CW1  3<br>Question 4<br>A leap year is a year with 366 days. A leap year has the 29 th February. A year is a leap year if it is<br>divisible by 4 except for the century years (divisible by 100). Century years are only leap years if they are<br>divisible by 400. Write a program that accepts a year and determines if it is a leap year.<br>Use a separate method to test if a year is a leap year.<br>The following information will help when you test your program. The leap years 1800 to 2400:<br>1804  1904  2004  2104  2204  2304<br>1808  1908  2008  2108  2208  2308<br>1812  1912  2012  2112  2212  2312<br>1816  1916  2016  2116  2216  2316<br>1820  1920  2020  2120  2220  2320<br>1824  1924  2024  2124  2224  2324<br>1828  1928  2028  2128  2228  2328<br>1832  1932  2032  2132  2232  2332<br>1836  1936  2036  2136  2236  2336<br>1840  1940  2040  2140  2240  2340<br>1844  1944  2044  2144  2244  2344<br>1848  1948  2048  2148  2248  2348<br>1852  1952  2052  2152  2252  2352<br>1856  1956  2056  2156  2256  2356<br>1860  1960  2060  2160  2260  2360<br>1864  1964  2064  2164  2264  2364<br>1868  1968  2068  2168  2268  2368<br>1872  1972  2072  2172  2272  2372<br>1876  1976  2076  2176  2276  2376<br>1880  1980  2080  2180  2280  2380<br>1884  1984  2084  2184  2284  2384<br>1888  1988  2088  2188  2288  2388<br>1892  1992  2092  2192  2292  2392<br>1896  1996  2096  2196  2296  2396<br>2000<br>2400<br>CSE105 CW1  4<br>Question 5<br>Write Java program to check if a number is Armstrong number.<br>An Armstrong number of 3 digit is a number for which sum of cube of its digits are equal to the<br>number.<br>Examples:<br>371 is an Armstrong number because 3</em>3<em>3 + 7</em>7<em>7 + 1</em>1<em>1 = 371.<br>123 is not an Armstrong number because 1</em>1<em>1 + 2</em>2<em>2 + 3</em>3*3 = 36.<br>This assignment is individual work. Plagiarism (e.g. copying materials from other<br>sources without proper acknowledgement) is a serious academic offence. Plagiarism<br>will not be tolerated and will be dealt with in accordance with the University Code of<br>Practice on Assessment.<br><br><br><br><br></font>
    
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

</article>
    </li>
  
</ul>

<nav id="page-nav">
    <div class="inner">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
    </div>
</nav>

    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "留学生Computer Science编程作业代写",
    pic: "/img/logo.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://yoursite.com/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>



<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>









</body>
</html>
