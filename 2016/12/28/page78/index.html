<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java代写 Programming Assignment 2  Link State Routing | 留学生CS代写|代做java编程|C++程序|C作业|Python代码 | 专业 高效 原创</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="Java,Algorithm,Network">
  <meta name="description" content="Introductionjava的网络编程，完成状态路由协议，本题主要考察java基础，网络编程基础，设计路由协议，Dijkstra’s算法，UDP套接字协议，动态路由等等知识，分为2个partRequirementCOMP 3331/9331: Computer Networks &amp;amp; ApplicationsProgramming Assignment 2: Link State Rou">
<meta property="og:type" content="article">
<meta property="og:title" content="Java代写 Programming Assignment 2  Link State Routing">
<meta property="og:url" content="http://yoursite.com/2016/12/28/page78/index.html">
<meta property="og:site_name" content="留学生CS代写|代做java编程|C++程序|C作业|Python代码">
<meta property="og:description" content="Introductionjava的网络编程，完成状态路由协议，本题主要考察java基础，网络编程基础，设计路由协议，Dijkstra’s算法，UDP套接字协议，动态路由等等知识，分为2个partRequirementCOMP 3331/9331: Computer Networks &amp;amp; ApplicationsProgramming Assignment 2: Link State Rou">
<meta property="og:updated_time" content="2017-01-12T03:49:18.869Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java代写 Programming Assignment 2  Link State Routing">
<meta name="twitter:description" content="Introductionjava的网络编程，完成状态路由协议，本题主要考察java基础，网络编程基础，设计路由协议，Dijkstra’s算法，UDP套接字协议，动态路由等等知识，分为2个partRequirementCOMP 3331/9331: Computer Networks &amp;amp; ApplicationsProgramming Assignment 2: Link State Rou">
  
    <link rel="alternative" href="/atom.xml" title="留学生CS代写|代做java编程|C++程序|C作业|Python代码" type="application/atom+xml">
  
  <meta name="summary" content="专业团队帮您代写代做Computer Science的Assignment/Lab/Homework/Project，无中介费用，专业,高效,原创">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu" class="hide" >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logo.jpg"></a>
      <hgroup class="introduce">
        <h5 class="nickname">csyoyo</h5>
        <a href="mailto:undefined" title="cscoderman@gmail.com" class="mail">cscoderman@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            标签
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            归档
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-user"></i>
            关于我
          </a>
        </li>
    
  </ul>

  <footer class="footer">
    <img src="/img/qrcode.jpg" alt="">
  <p><h4>微信</h4></p>
  <p>csyoyo</p>
  <p><h4>邮箱</h4></p>
  <p>cscoderman@gmail.com</p>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Java代写 Programming Assignment 2  Link State Routing</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">Java代写 Programming Assignment 2  Link State Routing</h1>
    <h5 class="subtitle">
          
            <time datetime="2016-12-28T04:12:34.000Z" itemprop="datePublished" class="page-time">
  2016-12-28
</time>

 
        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <article id="post-page78" 
  class="article article-type-post" itemprop="blogPost">
    <div class="post-meat flex-row">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Network/">Network</a></li></ul>

    </div>
    <div class="post-body">
        <aside class="post-widget" id="post-widget">

            
            <div class="post-share" id="post-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>

            

            
            <nav class="post-toc-wrap" id="post-toc">
            
            </nav>
            
        </aside>

        <div class="post-main">

            <div class="post-content" id="post-content" itemprop="postContent">
            <font size="4"><br><strong>Introduction</strong><br>java的网络编程，完成状态路由协议，本题主要考察java基础，网络编程基础，设计路由协议，Dijkstra’s算法<br>，UDP套接字协议，动态路由等等知识，分为2个part<br><br><br><strong>Requirement</strong><br><br>COMP 3331/9331: Computer Networks &amp; Applications<br>Programming Assignment 2: Link State Routing<br>Due Date: 28 Oct 2016, 11:59 pm (Week 13) Marks: 10 + 1 bonus<br>1. Change Log<br>Version 1.0 released on 19 th September 2016.<br>2. Goal and Learning Objectives<br>In this assignment your task is to implement the link state routing protocol. Your program will be<br>running at all nodes in the specified network. At each node the input to your program is a set of<br>directly attached nodes (i.e. neighbours) and the costs of these links. Each node will broadcast<br>link-state packets to all other nodes in the network. Your routing program at each node should<br>report the least-cost path and the associated cost to all other nodes in the network. Your program<br>should be able to deal with failed nodes.<br>2.1 Learning Objectives<br>On completing this assignment you will gain sufficient expertise in the following skills:<br>• Designing a routing protocol<br>• Link state (Dijkstra’s) algorithm<br>• UDP socket programming<br>• Handling routing dynamics<br>3. Assignment Specification<br>This section gives detailed specifications of the assignment. You can receive 1 bonus mark for<br>submitting the assignment 1 week prior to the deadline.<br>3.1 Implementation Details<br>In this assignment, you will implement the link state routing protocol.<br>The program will accept the following command line arguments:<br>• NODE_ID, the ID for this node. This argument must be a single uppercase alphabet (e.g., A,<br>B, etc).<br>• NODE_PORT, the port number on which this node will send and receive packets to and from<br>its neighbours.<br>Updates to the assignment, including any corrections and clarifications, will be posted on the<br>subject website. Please make sure that you check the subject website regularly for updates.<br>• CONFIG.TXT, this file will contain the costs to the neighbouring nodes. It will also contain<br>the port number being used by each neighbour for exchanging routing packets. An example of<br>this file is provided below.<br>Since we can’t let you play with real network routers, the routing programs for all the nodes in the<br>simulated network will run on a single desktop machine. However, each instance of the routing<br>protocol (corresponding to each node in the network) will be listening on a different port number.<br>If your routing software executes correctly on a single desktop machine, it should also work<br>correctly on real network routers. Note that, the terms router and node are used interchangeably in<br>the rest of this specification.<br>Assume that the routing protocol is being instantiated for a node A, with two neighbours B and C.<br>A simple example of how the routing program would be executed (assuming it is a Java program<br>named Lsr.java) follows:<br>java Lsr A 2000 config.txt<br>where the config.txt would be as follows:<br>2<br>B 5 2001<br>C 7 2002<br>The first line of this file indicates the number of neighbours (NOT the total number of nodes in the<br>network). Following this there is one line dedicated to each neighbour. It starts with the neighbour<br>id, followed by the cost to reach this neighbour and finally the port number that this neighbour is<br>using for communication. For example, the second line in the config.txt above indicates that the<br>cost to neighbour B is 5 and this neighbour is using port number 2001 for receiving and<br>transmitting link-state packets. The node ids will be uppercase alphabets and you can assume that<br>there will be no more than 10 nodes in the test scenarios. However, do not make assumptions that<br>the node ids will necessarily start from the letter A or that they will always be in sequence. The<br>link costs should be floating point numbers (up to the first decimal) and the port numbers should<br>be integers. These three fields will be separated by a single white space between two successive<br>fields in each line of the configuration file. The link costs will be static and will not change once<br>initialised. Further, the link costs will be consistent in both directions, i.e., if the cost from A to B<br>is 5, then the link from B to A will also have a cost of 5. You may assume that the configuration<br>files used for marking will be consistent with the above description and devoid of any errors.<br>Important: It is worth restating that initially each node is only aware of the costs to its direct<br>neighbours. The nodes do not have global knowledge (i.e. information about the entire network<br>topology) at start-up.<br>The remainder of the specification is divided into two parts, beginning with the base specification<br>as the first part and the subsequent part adding new functionality to the base specification. In order<br>to receive full marks for this assignment you must implement both parts. If you are unable to<br>complete the second part, you will still receive marks for the first part. (The marking guidelines at<br>the end of the specification indicate the distribution of marks).<br>Part 1: Base Specification<br>In link-state routing, each node broadcasts link-state packets to all other nodes in the network, with<br>each link-state packet containing the identities of the node’s neighbours and the associated costs to<br>reach them. You must implement a simple broadcasting mechanism in your program. Upon<br>initialisation, each node creates a link-state packet (containing the appropriate information – see<br>description of link-state protocol in the textbook/lecture notes) and sends this packet to all direct<br>neighbours. The exact format of the link-state packets that you will use is left for you to decide.<br>Upon receiving this link-state packet, each neighbouring router in turn broadcasts this packet to its<br>own neighbours (excluding the router from which it received this link-state packet in the first<br>place). This simple flooding mechanism will ensure that each link-state packet is propagated<br>through the entire network.<br>It is possible that some nodes may start earlier than their neighbours. As a result, a node might<br>send the link-state packet to a neighbour, which has not run yet. You should not worry about this<br>since the routing program at each node will repeatedly send the link-state packet to its neighbours<br>and a slow-starting neighbour will eventually get the information. That said, when we test your<br>assignment, we would ensure that all nodes are initiated simultaneously (using a script).<br>Each node should periodically broadcast the link-state packet to its neighbours every<br>UPDATE_INTERVAL. You should set this interval to 1 second. In other words, a node should<br>broadcast a link state packet every second.<br>Real routing protocols use UDP for exchanging control packets. Hence, you MUST use UDP as<br>the transport protocol for exchanging link-state packets amongst the neighbours. Note that, each<br>router can consult its configuration file to determine the port numbers used by its neighbours for<br>exchanging link-state packets. Do not worry about the unreliable nature of UDP. Since, you are<br>simulating multiple routers on a single machine, it is highly unlikely that link-state packets will be<br>dropped. Furthermore, since link-state packets are broadcast periodically, occasional packet loss<br>will not impact the operation of your protocol. If you use TCP, a significant penalty will be<br>assessed.<br>On receiving link-state packets from all other nodes, a router can build up a global view of the<br>network topology. You may want to review your class notes and consult standard data structures<br>textbooks for standard representations of undirected graphs, which would be an appropriate way to<br>model this view of the network.<br>Given a view of the entire network topology, a router should run Dijkstra’s algorithm to compute<br>least-cost paths to all other routers within the network. Each node should wait for a<br>ROUTE_UPDATE_INTERVAL (the default value is 30 seconds) since start-up and then execute<br>Dijkstra’s algorithm. Given that there will be no more than 10 nodes in the network and a periodic<br>link-state broadcast frequency of 1 second, 30 seconds is a sufficiently long duration for each node<br>to discover the global view of the entire topology.<br>Once a router finishes running Dijkstra’s algorithm, it should print out to the terminal, the least-<br>cost path to each destination node (excluding itself) along with the cost of this path. The following<br>is an example output for node A in some arbitrary network:<br>least-cost path to node B: ACB and the cost is 10<br>least-cost path to node C: AC and the cost is 2.5<br>We will wait for duration of ROUTE_UPDATE_INTERVAL after running your program for the<br>output to appear (some extra time will be added as a buffer). If the output does not appear within<br>this time, you will be heavily penalised. As indicated earlier, we will restrict the size of the<br>network to 10 nodes in the test topologies. The default value of 30 seconds is sufficiently long for<br>all the nodes to receive link-state packets from every other node and compute the least-cost paths.<br>Your program should execute forever (as a loop). In other words, each node should keep<br>broadcasting link-state packets every UPDATE_INTERVAL and Dijkstra’s algorithm should be<br>executed and the output printed out every ROUTE_UPDATE_INTERVAL. To kill an instance of<br>the routing protocol, the user should type CTRL-C at the respective terminal.<br>Restricting Link-state Broadcasts: Note that, a naïve broadcast strategy; wherein each node<br>retransmits every link state packet that it receives will result in unnecessary broadcasts and thus<br>increase the overhead. To elaborate this issue, consider the example topology discussed in the<br>latter part of the spec. The link-state packet created by node A will be sent to its direct neighbours<br>B, C and D. Each of these three nodes will in turn broadcast this link-state packet to their<br>neighbours. Let us consider Node C, which broadcasts A’s link state packet to B, D, E and F. Note<br>that node B has already broadcast A’s link state packet once (when it received it directly from A).<br>Node B has now received this same link-state packet via node C. There should thus be no need for<br>node B to broadcast this packet again. You MUST implement a mechanism to reduce such<br>unnecessary broadcasts. This can be achieved in several ways. You are open to choose any method<br>to achieve this. You must describe your method in the written report.<br>Part 2: Dealing with Node Failures<br>In this part you must implement additional functionality in your code to deal with random node<br>failures. Recall that in the base assignment specification it is assumed that once all nodes are up<br>and running they will continue to be operational till the end when all nodes are terminated<br>simultaneously. In this part you must ensure that your algorithm is robust to node failures. Once a<br>node fails, its neighbours must quickly be able to detect this and the corresponding links to this<br>failed node must be removed. Further, the routing protocol should converge and the failed nodes<br>should be excluded from the least-cost path computations. The other nodes should no longer<br>compute least-cost paths to the failed nodes. Furthermore, the failed nodes should not be included<br>in the least-cost paths to other nodes.<br>A simple method that is often used to detect node failures is the use of periodic heartbeat (also<br>often known as keep alive) messages. A heartbeat message is a short control message, which is<br>periodically sent by a node to its directly connected neighbours. If a node does not receive a<br>certain number of consecutive hearbeat messages from one of its neighbours it can assume that<br>this node has failed. Note that, each node transmits a link-state packet to its immediate neighbour<br>every UPDATE_INTERVAL (1 second). Hence, this distance vector message could also double<br>up as the hearbeat message. Alternately, you may wish to make use of an explicit heartbeat<br>message (over UDP), which is transmitted more frequently (i.e. with a period less than 1 second)<br>to expedite the detection of a failed node. It is recommended that you wait till at least 3 consequent<br>hearbeat (or link-state) messages are not received from a neighbour before considering it to have<br>failed. This will ensure that if at all a UDP packet is lost then it does not hamper the operation of<br>your protocol.<br>Once a node has detected that one of its neighbours has failed, it should update its link-state packet<br>accordingly to reflect the change in the local topology. Eventually, via the propagation of the<br>updated link-state packets, other nodes in the network will become aware that the failed node is<br>unreachable and it will be excluded from the link-state computations (i.e. Dijkstra’s algorithm).<br>Once a node has failed, you may assume that it cannot be initialised again.<br>While marking, we will only fail a few nodes, so that a reasonable connected topology is still<br>maintained. Furthermore, care will be taken to ensure that the network does not get partitioned. In<br>a typical topology (recall that the largest topology used for testing will consist of 10 nodes), at<br>most 3 nodes will fail. However, note that the nodes do not have to fail simultaneously.<br>Recall  that  each  node  will  execute  Dijkstra’s  algorithm  periodically  after<br>ROUTE_UPDATE_INTERVAL (30 seconds) to compute the least-cost path to every other<br>destination. It may so happen that the updated link-state packets following a node failure may not<br>have reached certain nodes in the network before this interval expires. As a result, these nodes will<br>use the old topology information (prior to node failure) to compute the least-cost paths. Thus the<br>output at these nodes will be incorrect. This is not an error. It is just an artefact of the delay<br>incurred in propagating the updated link-state information. To account for this, it is necessary to<br>wait for at least two consecutive ROUTE_UPDATE_INTERVAL periods (i.e. 1 minute) after the<br>node failure is initiated. This will ensure that all the nodes are aware of the topology change.<br>While marking, we will wait for 2<em>ROUTE_UPDATE_INTERVAL following a node failure<br>before checking the output.<br>3.2. An Example<br>Let us look at an example with the network topology as shown in the figure below:<br>The numbers alongside the links indicate the link costs. The configuration files for the 6 nodes are<br>available for download from the assignment webpage. In the configuration files we have assumed<br>the following port assignments: A at 2000, B at 2001, C at 2002, D at 2003, E at 2004 and F at<br>2005. However note that some of these ports may be in use by another student logged on to the<br>same CSE machine as you. In this case, change the port assignments in all the configuration files<br>appropriately. The program output at node A should look like the following:<br>least-cost path to node B: AB and the cost is 2.0<br>least-cost path to node C: ADEC and the cost is 3.0<br>least-cost path to node D: AD and the cost is 1.0<br>least-cost path to node E: ADE and the cost is 2.0<br>least-cost path to node F: ADEF and the cost is 4.0<br>Note: It is not necessary that your program should print the paths to the destinations in<br>alphabetical order.<br>You may also test out the ability of your program to deal with node failures in the above example<br>by causing node B to fail (as an example).<br>Please ensure that before you submit, your program provides a similar output for the above<br>topology. However, we will use different network topologies in our testing.<br>4. Additional Notes<br>This is not a group assignment. You are expected to work on this individually.<br>How to start: Sample UDP client and server programs are available on the Week 3 lecture<br>material page. They are a good starting point to start your development. You will also find several<br>links to network programming resources on that page.<br>A<br>D<br>B  C<br>E<br>F<br>2<br>2<br>5<br>1<br>1<br>1<br>3<br>2<br>5<br>3<br>Language and Platform: You are free to use one of C, JAVA or Python to implement this<br>assignment. Please choose a language that you are comfortable with. The programs will be tested<br>on CSE Linux machines. So please make sure that your entire application runs correctly on these<br>machines. This is especially important if you plan to develop and test the programs on your<br>personal computers (which may possibly use a different OS or version or JVM). Note that CSE<br>machines support the following: gcc version 4.9.2, Java 1.7, Python 2.7, 2.8 and 3. Note for<br>Python: In your report, please indicate which version of Python you have used. You may only use<br>the basic socket programming APIs providing in your programming language of choice. Note that,<br>the network will be simulated by running multiple instances of your program on the same machine<br>with a different port number for each node. Make sure that your program will work appropriately<br>under these conditions. See the sequence of operations listed below for details.<br>Error Condition: Note that all the arguments supplied to the programs will be in the appropriate<br>format. The configuration files supplied as an argument to each node will also be consistent with<br>the test topology. Your programs do not have to handle errors in format, etc.<br>You should be aware that port ID’s, when bound to sockets, are system-wide values and thus other<br>students may be using the port number you are trying to use. On Linux systems, you can run the<br>command netstat to see which port numbers are currently assigned.<br>Do not worry about the reliability of UDP in your assignment. It is possible for packets to be<br>dropped, for example, but the chances of problems occurring in a local area network are fairly<br>small. If it does happen on the rare occasion, that is fine. Further, your routing protocol is<br>inherently robust against occasional losses since the link state packets are exchanged every 1<br>second. If your program appears to be losing or corrupting packets on a regular basis, then there is<br>likely a fault in your program.<br>Test your assignment out with several different topologies (besides the sample topology provided).<br>Make sure that your program is robust to node failures by creating several failed nodes (however<br>make sure that the topology is still connected). You can very easily work out the least-cost paths<br>manually (as shown in the lecture notes or the textbook) to verify the output of your program.<br>5. File Naming Convention and Assignment Submission<br>Your main program should be named Lsr.c (or Lsr.java or Lsr.py). You may of course have<br>additional header files and/or helper files. If you are using C you MUST submit a makefile/script<br>(not necessary with Java and Python). In addition you should submit a small report, report.pdf<br>(no more than 3 pages) describing the program design and a brief description of how your system<br>works. Describe the data structure used to represent the network topology and the link-state packet<br>format. Comment on how your program deals with node failures and restricts excessive link-state<br>broadcasts. Also discuss any design tradeoffs considered and made. Describe possible<br>improvements and extensions to your program and indicate how you could realise them. If your<br>program does not work under any particular circumstances please report this here. Also indicate<br>any segments of code that you have borrowed from the Web or other books.<br>You do not have to submit any topology files.<br>Here are the step-by-step instructions for submission:<br>1. Log in to your CSE account.<br>2. Create a directory called assign and copy ONLY the necessary files into that directory.<br>3. Tar this directory using the following command: “tar –cvf assign.tar assign”<br>4. Submit your assignment using the following command: “give cs3331 assign2 assign.tar”. You<br>should receive a confirmation of your submission.<br>Alternately, you may submit the tar archive via the submission link at the top of the assignment<br>web page.<br>Note that, the system will only accept assign.tar as the file name. All other names will be rejected.<br>You can submit as many times as you like before the deadline. A later submission will override<br>the previous submission, so make sure you submit the correct version. Do not wait till just before<br>the deadline for submission, as there may be unforeseen problems (brief disconnection of Internet<br>connectivity, power outage, computer crash, etc.).<br>Late Submission Penalty: Late penalty will be applied as follows:<br>• 1 day after deadline: 10% reduction<br>• 2 days after deadline: 20% reduction<br>• 3 days after deadline: 30% reduction<br>• 4 days after deadline: 40% reduction<br>• 5 or more days late: NOT accepted<br>NOTE: The above penalty is applied to your final total. For example, if you submit your<br>assignment 2 days late and your score on the assignment is 10, then your final mark will be 10 – 2<br>(20% penalty) = 8.<br>6. Plagiarism<br>You are to write all of the code for this assignment yourself. All source codes are subject to strict<br>checks for plagiarism, via highly sophisticated plagiarism detection software. These checks may<br>include comparison with available code from Internet sites and assignments from previous<br>semesters. In addition, each submission will be checked against all other submissions of the<br>current semester. Do not post this assignment on forums where you can pay programmers to write<br>code for you. We will be monitoring such forums. Please note that we take this matter quite<br>seriously. The LIC will decide on appropriate penalty for detected cases of plagiarism. The most<br>likely penalty would be to reduce the assignment mark to ZERO.<br>That said, we are aware that a lot of learning takes place in student conversations, and don’t wish<br>to discourage you from taking your classmates, provided you follow the Gilligan’s Island Rule -<br>After a joint discussion of an assignment or problem, each student should discard all written<br>material and then go do something mind-numbing for half an hour. For example, go watch an<br>episode of Gilligan’s Island (or Reality TV in modern terms), and then recreate the solutions. The<br>idea of this policy is to ensure that you fully understand the solutions or ideas that the group came<br>up with.<br>It is important, for both those helping others and those being helped, not to provide/accept any<br>programming language code in writing, as this is apt to be used exactly as is, and lead to<br>plagiarism penalties for both the supplier and the copier of the codes. Write something on a piece<br>of paper, by all means, but tear it up/take it away when the discussion is over. It is OK to borrow<br>bits and pieces of code from sample socket code out on the Web and in books. You MUST<br>however acknowledge the source of any borrowed code. This means providing a reference to a<br>book or a URL when the code appears (as comments). Also indicate in your report the portions of<br>your code that were borrowed. Explain any modifications you have made (if any) to the borrowed<br>code.<br>7. Forum Use<br>Students are strongly recommended to discuss about the assignment on the course forum.<br>However, at no point should any code fragments be posted to the message forum. Such actions<br>will be considered to be instances of plagiarism, thus incurring a significant penalty. Students are<br>also encouraged to share example topologies that they have created to test their program.<br>8. Sequence of Operation for Testing<br>The following shows the sequence of events that will be involved in the testing of your<br>assignment. Please ensure that before you submit your code you thoroughly check that your code<br>can execute these operations successfully.<br>1) First chose an arbitrary network topology (similar to the test topology above). Create the<br>appropriate configuration files that need to be input to the nodes. Note again that the<br>configuration files should only contain information about the neighbours and not of the entire<br>topology. Work out the least-cost paths and corresponding costs from each node to all other<br>destinations manually using Dijkstra’s algorithm as described in the lecture notes (or<br>textbook). This will allow you to check that your program is computing the paths correctly.<br>2) Log on to a CSE Linux machine. Open as many terminal windows as the number of nodes in<br>your test topology. Almost simultaneously, execute the routing protocol for each node (one<br>node in each terminal).<br>java lsr A 2000 configA.txt (for JAVA)<br>java lsr B 2001 configB.txt<br>and so on. You may write a simple script to automate this process.<br>3) Wait till the nodes display the output at their respective terminals.<br>4) Compare the displayed paths and costs to the ones obtained in step 1 above. These should be<br>consistent.<br>5) The next step involves testing the capability of your program to deal with failed nodes. For this<br>choose a few nodes (max of 3 nodes) from the topology that is currently being tested (in the<br>above tests) and terminate the nodes by typing CTRL-C in their respective terminal windows.<br>Make sure that the nodes chosen for termination do not partition the network. Work out the<br>least-cost paths from each node to all other destinations manually using Dijkstra’s algorithm as<br>described  in  the  lecture  notes  (or  textbook).  Wait  for  a  duration  of<br>2</em>ROUTE_UPDATE_INTERVAL and observe the updated output at each node. Corroborate<br>the results with the manual computations.<br>6) Terminate all nodes.<br>NOTE: We will ensure that your programs are tested multiple times to account for any possible<br>UDP segment losses (it is quite unlikely that your routing packets will be dropped).<br>9. Marking Policy:<br>We will test your routing protocol for at least 2 different network topologies (which will be<br>distinct from the example provided). Marks will be deducted if necessary, depending on the extent<br>of the errors observed in the output at each node. After the marking process we will upload the test<br>topologies on the website for all students to view.<br>Your code will be marked using the following criteria:<br>• Mechanism to restrict link-state broadcasts: 1 marks<br>• Correct operation of the link state protocol: 5.5 marks<br>• Appropriate handling of dead nodes, whereby the least-cost paths are updated to reflect the<br>change in topology: 2.5 marks<br>• Report: 1 mark<br>Bonus Mark: You may receive 1 bonus mark for submitting the assignment a week before the<br>deadline, i.e. by 21 st October 2016 (Week 12). However, to receive the bonus mark, in addition<br>to submitting by the early deadline, your code should have scored at least 7 marks (out of 10) as<br>per the above criteria. The bonus mark can be used to offset lost marks in any assessable<br>component in this course (e.g. mid-semester exam, final exam, labs, etc.).<br>IMPORTANT NOTE: For assignments that fail to execute all of the above tests, we will be<br>unable to award you a substantial mark. Note that, we will test your code multiple times before<br>concluding that there is a problem. You should test your program rigorously and verify the results<br>by trying out different topologies before submitting your code.<br><br><br><br></font>
            <blockquote>
                <p>
                本文地址：
                <a href="http://yoursite.com/2016/12/28/page78/" target="_blank" rel="external">http://yoursite.com/2016/12/28/page78/</a>
                </p>
                <footer><cite><a href="http://yoursite.com">@留学生CS代写|代做java编程|C++程序|C作业|Python代码</a></cite></footer>
            </blockquote>
            </div>
            
<nav class="post-nav">
  
    <div class="waves-block waves-effect prev fl">
      <a href="/2016/12/29/page79/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Java代写 A Simple Student Management System</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next fr">
      <a href="/2016/12/27/page77/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">C++代写 CS1073  Data Structures and Algorithms</h4>
      </a>
    </div>
  
</nav>


            
            
<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="page78" data-title="Java代写 Programming Assignment 2  Link State Routing" data-url="http://yoursite.com/2016/12/28/page78/index.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"ysblog"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





        </div>
    </div>
</article>
    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "Java代写 Programming Assignment 2  Link State Routing",
    pic: "/img/logo.jpg",
    summary: document.getElementsByName('summary')[0].content,
    url: "http://yoursite.com/2016/12/28/page78/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>



<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>









</body>
</html>
